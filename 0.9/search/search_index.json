{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ramifice","text":"<p> ORM-pseudo-like API MongoDB for Python language. <p> </p> </p> <p></p> <p> Ramifice is built around PyMongo.   For simulate relationship Many-to-One and Many-to-Many,  a simplified alternative (Types of selective fields with dynamic addition of elements) is used.  The project is more concentrated for web development or for applications with a graphic interface. </p> <p></p>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"pages/commons/","title":"Commons","text":"<p>Commons - Model class methods.</p>"},{"location":"pages/commons/general/","title":"General","text":"<p>General purpose query methods.</p>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin","title":"<code>GeneralMixin</code>","text":"<p>General purpose query methods.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>class GeneralMixin:\n    \"\"\"General purpose query methods.\"\"\"\n\n    @classmethod\n    def from_mongo_doc(\n        cls,\n        mongo_doc: dict[str, Any],\n    ) -&gt; Any:\n        \"\"\"Create object instance from Mongo document.\"\"\"\n        obj: Any = cls()\n        lang: str = translations.CURRENT_LOCALE\n        for name, data in mongo_doc.items():\n            field = obj.__dict__.get(name)\n            if field is None:\n                continue\n            if field.field_type == \"TextField\":\n                field.value = data.get(lang, \"- -\") if data is not None else None\n            elif field.group == \"pass\":\n                field.value = None\n            else:\n                field.value = data\n        return obj\n\n    @classmethod\n    async def estimated_document_count(  # type: ignore[no-untyped-def]\n        cls,\n        comment: Any | None = None,\n        **kwargs,\n    ) -&gt; int:\n        \"\"\"Get an estimate of the number of documents in this collection using collection metadata.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        #\n        return await collection.estimated_document_count(\n            comment=comment,\n            **kwargs,\n        )\n\n    @classmethod\n    async def count_documents(  # type: ignore[no-untyped-def]\n        cls,\n        filter: Any,\n        session: Any | None = None,\n        comment: Any | None = None,\n        **kwargs,\n    ) -&gt; int:\n        \"\"\"Count the number of documents in this collection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n\n        return await collection.count_documents(\n            filter=filter,\n            session=session,\n            comment=comment,\n            **kwargs,\n        )\n\n    @classmethod\n    async def aggregate(  # type: ignore[no-untyped-def]\n        cls,\n        pipeline: Any,\n        session: Any | None = None,\n        let: Any | None = None,\n        comment: Any | None = None,\n        **kwargs,\n    ) -&gt; AsyncCommandCursor:\n        \"\"\"Perform an aggregation using the aggregation framework on this collection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if pipeline is not None:\n            pipeline = correct_mongo_filter(cls, pipeline)\n\n        return await collection.aggregate(\n            pipeline=pipeline,\n            session=session,\n            let=let,\n            comment=comment,\n            **kwargs,\n        )\n\n    @classmethod\n    async def distinct(  # type: ignore[no-untyped-def]\n        cls,\n        key: Any,\n        filter: Any | None = None,\n        session: Any | None = None,\n        comment: Any | None = None,\n        hint: Any | None = None,\n        **kwargs,\n    ) -&gt; list[Any]:\n        \"\"\"Get a list of distinct values for key among all documents in this collection.\n\n        Returns an array of unique values for specified field of collection.\n        \"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n\n        return await collection.distinct(\n            key=key,\n            filter=filter,\n            session=session,\n            comment=comment,\n            hint=hint,\n            **kwargs,\n        )\n\n    @classmethod\n    def collection_name(cls) -&gt; str:\n        \"\"\"The name of this AsyncCollection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        #\n        return collection.name\n\n    @classmethod\n    def collection_full_name(cls) -&gt; str:\n        \"\"\"The full name of this AsyncCollection.\n\n        The full name is of the form database_name.collection_name.\n        \"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        #\n        return collection.full_name\n\n    @classmethod\n    def database(cls) -&gt; AsyncDatabase:\n        \"\"\"Get AsyncBatabase for the current Model.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        #\n        return collection.database\n\n    @classmethod\n    def collection(cls) -&gt; AsyncCollection:\n        \"\"\"Get AsyncCollection for the current Model.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        #\n        return collection\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.aggregate","title":"<code>aggregate(pipeline, session=None, let=None, comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Perform an aggregation using the aggregation framework on this collection.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\nasync def aggregate(  # type: ignore[no-untyped-def]\n    cls,\n    pipeline: Any,\n    session: Any | None = None,\n    let: Any | None = None,\n    comment: Any | None = None,\n    **kwargs,\n) -&gt; AsyncCommandCursor:\n    \"\"\"Perform an aggregation using the aggregation framework on this collection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if pipeline is not None:\n        pipeline = correct_mongo_filter(cls, pipeline)\n\n    return await collection.aggregate(\n        pipeline=pipeline,\n        session=session,\n        let=let,\n        comment=comment,\n        **kwargs,\n    )\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.collection","title":"<code>collection()</code>  <code>classmethod</code>","text":"<p>Get AsyncCollection for the current Model.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\ndef collection(cls) -&gt; AsyncCollection:\n    \"\"\"Get AsyncCollection for the current Model.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    #\n    return collection\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.collection_full_name","title":"<code>collection_full_name()</code>  <code>classmethod</code>","text":"<p>The full name of this AsyncCollection.</p> <p>The full name is of the form database_name.collection_name.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\ndef collection_full_name(cls) -&gt; str:\n    \"\"\"The full name of this AsyncCollection.\n\n    The full name is of the form database_name.collection_name.\n    \"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    #\n    return collection.full_name\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.collection_name","title":"<code>collection_name()</code>  <code>classmethod</code>","text":"<p>The name of this AsyncCollection.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\ndef collection_name(cls) -&gt; str:\n    \"\"\"The name of this AsyncCollection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    #\n    return collection.name\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.count_documents","title":"<code>count_documents(filter, session=None, comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Count the number of documents in this collection.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\nasync def count_documents(  # type: ignore[no-untyped-def]\n    cls,\n    filter: Any,\n    session: Any | None = None,\n    comment: Any | None = None,\n    **kwargs,\n) -&gt; int:\n    \"\"\"Count the number of documents in this collection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n\n    return await collection.count_documents(\n        filter=filter,\n        session=session,\n        comment=comment,\n        **kwargs,\n    )\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.database","title":"<code>database()</code>  <code>classmethod</code>","text":"<p>Get AsyncBatabase for the current Model.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\ndef database(cls) -&gt; AsyncDatabase:\n    \"\"\"Get AsyncBatabase for the current Model.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    #\n    return collection.database\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.distinct","title":"<code>distinct(key, filter=None, session=None, comment=None, hint=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get a list of distinct values for key among all documents in this collection.</p> <p>Returns an array of unique values for specified field of collection.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\nasync def distinct(  # type: ignore[no-untyped-def]\n    cls,\n    key: Any,\n    filter: Any | None = None,\n    session: Any | None = None,\n    comment: Any | None = None,\n    hint: Any | None = None,\n    **kwargs,\n) -&gt; list[Any]:\n    \"\"\"Get a list of distinct values for key among all documents in this collection.\n\n    Returns an array of unique values for specified field of collection.\n    \"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n\n    return await collection.distinct(\n        key=key,\n        filter=filter,\n        session=session,\n        comment=comment,\n        hint=hint,\n        **kwargs,\n    )\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.estimated_document_count","title":"<code>estimated_document_count(comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get an estimate of the number of documents in this collection using collection metadata.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\nasync def estimated_document_count(  # type: ignore[no-untyped-def]\n    cls,\n    comment: Any | None = None,\n    **kwargs,\n) -&gt; int:\n    \"\"\"Get an estimate of the number of documents in this collection using collection metadata.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    #\n    return await collection.estimated_document_count(\n        comment=comment,\n        **kwargs,\n    )\n</code></pre>"},{"location":"pages/commons/general/#ramifice.commons.general.GeneralMixin.from_mongo_doc","title":"<code>from_mongo_doc(mongo_doc)</code>  <code>classmethod</code>","text":"<p>Create object instance from Mongo document.</p> Source code in <code>src/ramifice/commons/general.py</code> <pre><code>@classmethod\ndef from_mongo_doc(\n    cls,\n    mongo_doc: dict[str, Any],\n) -&gt; Any:\n    \"\"\"Create object instance from Mongo document.\"\"\"\n    obj: Any = cls()\n    lang: str = translations.CURRENT_LOCALE\n    for name, data in mongo_doc.items():\n        field = obj.__dict__.get(name)\n        if field is None:\n            continue\n        if field.field_type == \"TextField\":\n            field.value = data.get(lang, \"- -\") if data is not None else None\n        elif field.group == \"pass\":\n            field.value = None\n        else:\n            field.value = data\n    return obj\n</code></pre>"},{"location":"pages/commons/indexes/","title":"Indexes","text":"<p>Indexation documents of collection.</p>"},{"location":"pages/commons/indexes/#ramifice.commons.indexes.IndexMixin","title":"<code>IndexMixin</code>","text":"<p>Indexation documents of collection.</p> Source code in <code>src/ramifice/commons/indexes.py</code> <pre><code>class IndexMixin:\n    \"\"\"Indexation documents of collection.\"\"\"\n\n    @classmethod\n    async def create_index(  # type: ignore[no-untyped-def]\n        cls,\n        keys: Any,\n        session: Any | None = None,\n        comment: Any | None = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Creates an index on this collection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Create index.\n        result: str = await collection.create_index(\n            keys=keys,\n            session=session,\n            comment=comment,\n            **kwargs,\n        )\n        return result\n\n    @classmethod\n    async def drop_index(  # type: ignore[no-untyped-def]\n        cls,\n        index_or_name: Any,\n        session: Any | None = None,\n        comment: Any | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Drops the specified index on this collection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Delete index.\n        await collection.drop_index(\n            index_or_name=index_or_name,\n            session=session,\n            comment=comment,\n            **kwargs,\n        )\n\n    @classmethod\n    async def create_indexes(  # type: ignore[no-untyped-def]\n        cls,\n        indexes: Any,\n        session: Any | None = None,\n        comment: Any | None = None,\n        **kwargs,\n    ) -&gt; list[str]:\n        \"\"\"Create one or more indexes on this collection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Create indexes.\n        result: list[str] = await collection.create_indexes(\n            indexes=indexes,\n            session=session,\n            comment=comment,\n            **kwargs,\n        )\n        return result\n\n    @classmethod\n    async def drop_indexes(  # type: ignore[no-untyped-def]\n        cls,\n        session: Any | None = None,\n        comment: Any | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Drops all indexes on this collection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Delete indexes.\n        await collection.drop_indexes(session=session, comment=comment, **kwargs)\n\n    @classmethod\n    async def index_information(\n        cls,\n        session: Any | None = None,\n        comment: Any | None = None,\n    ) -&gt; Any:\n        \"\"\"Get information on this collection\u2019s indexes.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        #\n        return await collection.index_information(session=session, comment=comment)\n\n    @classmethod\n    async def list_indexes(\n        cls,\n        session: Any | None = None,\n        comment: Any | None = None,\n    ) -&gt; Any:\n        \"\"\"Get a cursor over the index documents for this collection.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        #\n        return await collection.list_indexes(session=session, comment=comment)\n</code></pre>"},{"location":"pages/commons/indexes/#ramifice.commons.indexes.IndexMixin.create_index","title":"<code>create_index(keys, session=None, comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Creates an index on this collection.</p> Source code in <code>src/ramifice/commons/indexes.py</code> <pre><code>@classmethod\nasync def create_index(  # type: ignore[no-untyped-def]\n    cls,\n    keys: Any,\n    session: Any | None = None,\n    comment: Any | None = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Creates an index on this collection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Create index.\n    result: str = await collection.create_index(\n        keys=keys,\n        session=session,\n        comment=comment,\n        **kwargs,\n    )\n    return result\n</code></pre>"},{"location":"pages/commons/indexes/#ramifice.commons.indexes.IndexMixin.create_indexes","title":"<code>create_indexes(indexes, session=None, comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create one or more indexes on this collection.</p> Source code in <code>src/ramifice/commons/indexes.py</code> <pre><code>@classmethod\nasync def create_indexes(  # type: ignore[no-untyped-def]\n    cls,\n    indexes: Any,\n    session: Any | None = None,\n    comment: Any | None = None,\n    **kwargs,\n) -&gt; list[str]:\n    \"\"\"Create one or more indexes on this collection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Create indexes.\n    result: list[str] = await collection.create_indexes(\n        indexes=indexes,\n        session=session,\n        comment=comment,\n        **kwargs,\n    )\n    return result\n</code></pre>"},{"location":"pages/commons/indexes/#ramifice.commons.indexes.IndexMixin.drop_index","title":"<code>drop_index(index_or_name, session=None, comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Drops the specified index on this collection.</p> Source code in <code>src/ramifice/commons/indexes.py</code> <pre><code>@classmethod\nasync def drop_index(  # type: ignore[no-untyped-def]\n    cls,\n    index_or_name: Any,\n    session: Any | None = None,\n    comment: Any | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Drops the specified index on this collection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Delete index.\n    await collection.drop_index(\n        index_or_name=index_or_name,\n        session=session,\n        comment=comment,\n        **kwargs,\n    )\n</code></pre>"},{"location":"pages/commons/indexes/#ramifice.commons.indexes.IndexMixin.drop_indexes","title":"<code>drop_indexes(session=None, comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Drops all indexes on this collection.</p> Source code in <code>src/ramifice/commons/indexes.py</code> <pre><code>@classmethod\nasync def drop_indexes(  # type: ignore[no-untyped-def]\n    cls,\n    session: Any | None = None,\n    comment: Any | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Drops all indexes on this collection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Delete indexes.\n    await collection.drop_indexes(session=session, comment=comment, **kwargs)\n</code></pre>"},{"location":"pages/commons/indexes/#ramifice.commons.indexes.IndexMixin.index_information","title":"<code>index_information(session=None, comment=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get information on this collection\u2019s indexes.</p> Source code in <code>src/ramifice/commons/indexes.py</code> <pre><code>@classmethod\nasync def index_information(\n    cls,\n    session: Any | None = None,\n    comment: Any | None = None,\n) -&gt; Any:\n    \"\"\"Get information on this collection\u2019s indexes.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    #\n    return await collection.index_information(session=session, comment=comment)\n</code></pre>"},{"location":"pages/commons/indexes/#ramifice.commons.indexes.IndexMixin.list_indexes","title":"<code>list_indexes(session=None, comment=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get a cursor over the index documents for this collection.</p> Source code in <code>src/ramifice/commons/indexes.py</code> <pre><code>@classmethod\nasync def list_indexes(\n    cls,\n    session: Any | None = None,\n    comment: Any | None = None,\n) -&gt; Any:\n    \"\"\"Get a cursor over the index documents for this collection.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    #\n    return await collection.list_indexes(session=session, comment=comment)\n</code></pre>"},{"location":"pages/commons/many/","title":"Many","text":"<p>Queries like <code>find many</code>.</p>"},{"location":"pages/commons/many/#ramifice.commons.many.ManyMixin","title":"<code>ManyMixin</code>","text":"<p>Queries like <code>find many</code>.</p> Source code in <code>src/ramifice/commons/many.py</code> <pre><code>class ManyMixin:\n    \"\"\"Queries like `find many`.\"\"\"\n\n    @classmethod\n    async def find_many(\n        cls,\n        filter: Any | None = None,\n        projection: Any | None = None,\n        skip: int = 0,\n        limit: int = 0,\n        no_cursor_timeout: bool = False,\n        cursor_type: int = CursorType.NON_TAILABLE,\n        sort: Any | None = None,\n        allow_partial_results: bool = False,\n        oplog_replay: bool = False,\n        batch_size: int = 0,\n        collation: Any | None = None,\n        hint: Any | None = None,\n        max_scan: Any | None = None,\n        max_time_ms: Any | None = None,\n        max: Any | None = None,\n        min: Any | None = None,\n        return_key: bool = False,\n        show_record_id: bool = False,\n        comment: Any | None = None,\n        session: Any | None = None,\n        allow_disk_use: Any | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Find documents.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get documents.\n        doc_list: list[dict[str, Any]] = []\n        cursor: AsyncCursor = collection.find(\n            filter=filter,\n            projection=projection,\n            skip=skip,\n            limit=limit or cls.META[\"db_query_docs_limit\"],\n            no_cursor_timeout=no_cursor_timeout,\n            cursor_type=cursor_type,\n            sort=sort,\n            allow_partial_results=allow_partial_results,\n            oplog_replay=oplog_replay,\n            batch_size=batch_size,\n            collation=collation,\n            hint=hint,\n            max_scan=max_scan,\n            max_time_ms=max_time_ms,\n            max=max,\n            min=min,\n            return_key=return_key,\n            show_record_id=show_record_id,\n            comment=comment,\n            session=session,\n            allow_disk_use=allow_disk_use,\n        )\n        field_name_and_type = cls.META[\"field_name_and_type\"]\n        async for mongo_doc in cursor:\n            doc_list.append(password_to_none(field_name_and_type, mongo_doc))\n        return doc_list\n\n    @classmethod\n    async def find_many_to_raw_docs(\n        cls,\n        filter: Any | None = None,\n        projection: Any | None = None,\n        skip: int = 0,\n        limit: int = 0,\n        no_cursor_timeout: bool = False,\n        cursor_type: int = CursorType.NON_TAILABLE,\n        sort: Any | None = None,\n        allow_partial_results: bool = False,\n        oplog_replay: bool = False,\n        batch_size: int = 0,\n        collation: Any | None = None,\n        hint: Any | None = None,\n        max_scan: Any | None = None,\n        max_time_ms: Any | None = None,\n        max: Any | None = None,\n        min: Any | None = None,\n        return_key: bool = False,\n        show_record_id: bool = False,\n        comment: Any | None = None,\n        session: Any | None = None,\n        allow_disk_use: Any | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Find documents and convert to a raw documents.\n\n        Special changes:\n            _id to str\n            password to None\n            date to str\n            datetime to str\n        \"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get documents.\n        doc_list: list[dict[str, Any]] = []\n        cursor: AsyncCursor = collection.find(\n            filter=filter,\n            projection=projection,\n            skip=skip,\n            limit=limit or cls.META[\"db_query_docs_limit\"],\n            no_cursor_timeout=no_cursor_timeout,\n            cursor_type=cursor_type,\n            sort=sort,\n            allow_partial_results=allow_partial_results,\n            oplog_replay=oplog_replay,\n            batch_size=batch_size,\n            collation=collation,\n            hint=hint,\n            max_scan=max_scan,\n            max_time_ms=max_time_ms,\n            max=max,\n            min=min,\n            return_key=return_key,\n            show_record_id=show_record_id,\n            comment=comment,\n            session=session,\n            allow_disk_use=allow_disk_use,\n        )\n        inst_model_dict = {key: val for key, val in cls().__dict__.items() if not callable(val) and not val.ignored}\n        lang = translations.CURRENT_LOCALE\n        async for mongo_doc in cursor:\n            doc_list.append(\n                mongo_doc_to_raw_doc(\n                    inst_model_dict,\n                    mongo_doc,\n                    lang,\n                ),\n            )\n        return doc_list\n\n    @classmethod\n    async def find_many_to_json(\n        cls,\n        filter: Any | None = None,\n        projection: Any | None = None,\n        skip: int = 0,\n        limit: int = 0,\n        no_cursor_timeout: bool = False,\n        cursor_type: int = CursorType.NON_TAILABLE,\n        sort: Any | None = None,\n        allow_partial_results: bool = False,\n        oplog_replay: bool = False,\n        batch_size: int = 0,\n        collation: Any | None = None,\n        hint: Any | None = None,\n        max_scan: Any | None = None,\n        max_time_ms: Any | None = None,\n        max: Any | None = None,\n        min: Any | None = None,\n        return_key: bool = False,\n        show_record_id: bool = False,\n        comment: Any | None = None,\n        session: Any | None = None,\n        allow_disk_use: Any | None = None,\n    ) -&gt; str | None:\n        \"\"\"Find documents and convert to a json string.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get documents.\n        doc_list: list[dict[str, Any]] = []\n        cursor: AsyncCursor = collection.find(\n            filter=filter,\n            projection=projection,\n            skip=skip,\n            limit=limit or cls.META[\"db_query_docs_limit\"],\n            no_cursor_timeout=no_cursor_timeout,\n            cursor_type=cursor_type,\n            sort=sort,\n            allow_partial_results=allow_partial_results,\n            oplog_replay=oplog_replay,\n            batch_size=batch_size,\n            collation=collation,\n            hint=hint,\n            max_scan=max_scan,\n            max_time_ms=max_time_ms,\n            max=max,\n            min=min,\n            return_key=return_key,\n            show_record_id=show_record_id,\n            comment=comment,\n            session=session,\n            allow_disk_use=allow_disk_use,\n        )\n        inst_model_dict = {key: val for key, val in cls().__dict__.items() if not callable(val) and not val.ignored}\n        lang = translations.CURRENT_LOCALE\n        async for mongo_doc in cursor:\n            doc_list.append(\n                mongo_doc_to_raw_doc(\n                    inst_model_dict,\n                    mongo_doc,\n                    lang,\n                ),\n            )\n        return orjson.dumps(doc_list).decode(\"utf-8\") if len(doc_list) &gt; 0 else None\n\n    @classmethod\n    async def delete_many(\n        cls,\n        filter: Any,\n        collation: Any | None = None,\n        hint: Any | None = None,\n        session: Any | None = None,\n        let: Any | None = None,\n        comment: Any | None = None,\n    ) -&gt; DeleteResult:\n        \"\"\"Delete one or more documents matching the filter.\"\"\"\n        # Raises a panic if the Model cannot be removed.\n        if not cls.META[\"is_delete_doc\"]:\n            msg = (\n                f\"Model: `{cls.META['full_model_name']}` &gt; \"\n                + \"META param: `is_delete_doc` (False) =&gt; \"\n                + \"Documents of this Model cannot be removed from the database!\"\n            )\n            logger.error(msg)\n            raise ForbiddenDeleteDocError(msg)\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Delete documents.\n        result: DeleteResult = await collection.delete_many(\n            filter=filter,\n            collation=collation,\n            hint=hint,\n            session=session,\n            let=let,\n            comment=comment,\n        )\n        return result\n</code></pre>"},{"location":"pages/commons/many/#ramifice.commons.many.ManyMixin.delete_many","title":"<code>delete_many(filter, collation=None, hint=None, session=None, let=None, comment=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Delete one or more documents matching the filter.</p> Source code in <code>src/ramifice/commons/many.py</code> <pre><code>@classmethod\nasync def delete_many(\n    cls,\n    filter: Any,\n    collation: Any | None = None,\n    hint: Any | None = None,\n    session: Any | None = None,\n    let: Any | None = None,\n    comment: Any | None = None,\n) -&gt; DeleteResult:\n    \"\"\"Delete one or more documents matching the filter.\"\"\"\n    # Raises a panic if the Model cannot be removed.\n    if not cls.META[\"is_delete_doc\"]:\n        msg = (\n            f\"Model: `{cls.META['full_model_name']}` &gt; \"\n            + \"META param: `is_delete_doc` (False) =&gt; \"\n            + \"Documents of this Model cannot be removed from the database!\"\n        )\n        logger.error(msg)\n        raise ForbiddenDeleteDocError(msg)\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Delete documents.\n    result: DeleteResult = await collection.delete_many(\n        filter=filter,\n        collation=collation,\n        hint=hint,\n        session=session,\n        let=let,\n        comment=comment,\n    )\n    return result\n</code></pre>"},{"location":"pages/commons/many/#ramifice.commons.many.ManyMixin.find_many","title":"<code>find_many(filter=None, projection=None, skip=0, limit=0, no_cursor_timeout=False, cursor_type=CursorType.NON_TAILABLE, sort=None, allow_partial_results=False, oplog_replay=False, batch_size=0, collation=None, hint=None, max_scan=None, max_time_ms=None, max=None, min=None, return_key=False, show_record_id=False, comment=None, session=None, allow_disk_use=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Find documents.</p> Source code in <code>src/ramifice/commons/many.py</code> <pre><code>@classmethod\nasync def find_many(\n    cls,\n    filter: Any | None = None,\n    projection: Any | None = None,\n    skip: int = 0,\n    limit: int = 0,\n    no_cursor_timeout: bool = False,\n    cursor_type: int = CursorType.NON_TAILABLE,\n    sort: Any | None = None,\n    allow_partial_results: bool = False,\n    oplog_replay: bool = False,\n    batch_size: int = 0,\n    collation: Any | None = None,\n    hint: Any | None = None,\n    max_scan: Any | None = None,\n    max_time_ms: Any | None = None,\n    max: Any | None = None,\n    min: Any | None = None,\n    return_key: bool = False,\n    show_record_id: bool = False,\n    comment: Any | None = None,\n    session: Any | None = None,\n    allow_disk_use: Any | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Find documents.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get documents.\n    doc_list: list[dict[str, Any]] = []\n    cursor: AsyncCursor = collection.find(\n        filter=filter,\n        projection=projection,\n        skip=skip,\n        limit=limit or cls.META[\"db_query_docs_limit\"],\n        no_cursor_timeout=no_cursor_timeout,\n        cursor_type=cursor_type,\n        sort=sort,\n        allow_partial_results=allow_partial_results,\n        oplog_replay=oplog_replay,\n        batch_size=batch_size,\n        collation=collation,\n        hint=hint,\n        max_scan=max_scan,\n        max_time_ms=max_time_ms,\n        max=max,\n        min=min,\n        return_key=return_key,\n        show_record_id=show_record_id,\n        comment=comment,\n        session=session,\n        allow_disk_use=allow_disk_use,\n    )\n    field_name_and_type = cls.META[\"field_name_and_type\"]\n    async for mongo_doc in cursor:\n        doc_list.append(password_to_none(field_name_and_type, mongo_doc))\n    return doc_list\n</code></pre>"},{"location":"pages/commons/many/#ramifice.commons.many.ManyMixin.find_many_to_json","title":"<code>find_many_to_json(filter=None, projection=None, skip=0, limit=0, no_cursor_timeout=False, cursor_type=CursorType.NON_TAILABLE, sort=None, allow_partial_results=False, oplog_replay=False, batch_size=0, collation=None, hint=None, max_scan=None, max_time_ms=None, max=None, min=None, return_key=False, show_record_id=False, comment=None, session=None, allow_disk_use=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Find documents and convert to a json string.</p> Source code in <code>src/ramifice/commons/many.py</code> <pre><code>@classmethod\nasync def find_many_to_json(\n    cls,\n    filter: Any | None = None,\n    projection: Any | None = None,\n    skip: int = 0,\n    limit: int = 0,\n    no_cursor_timeout: bool = False,\n    cursor_type: int = CursorType.NON_TAILABLE,\n    sort: Any | None = None,\n    allow_partial_results: bool = False,\n    oplog_replay: bool = False,\n    batch_size: int = 0,\n    collation: Any | None = None,\n    hint: Any | None = None,\n    max_scan: Any | None = None,\n    max_time_ms: Any | None = None,\n    max: Any | None = None,\n    min: Any | None = None,\n    return_key: bool = False,\n    show_record_id: bool = False,\n    comment: Any | None = None,\n    session: Any | None = None,\n    allow_disk_use: Any | None = None,\n) -&gt; str | None:\n    \"\"\"Find documents and convert to a json string.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get documents.\n    doc_list: list[dict[str, Any]] = []\n    cursor: AsyncCursor = collection.find(\n        filter=filter,\n        projection=projection,\n        skip=skip,\n        limit=limit or cls.META[\"db_query_docs_limit\"],\n        no_cursor_timeout=no_cursor_timeout,\n        cursor_type=cursor_type,\n        sort=sort,\n        allow_partial_results=allow_partial_results,\n        oplog_replay=oplog_replay,\n        batch_size=batch_size,\n        collation=collation,\n        hint=hint,\n        max_scan=max_scan,\n        max_time_ms=max_time_ms,\n        max=max,\n        min=min,\n        return_key=return_key,\n        show_record_id=show_record_id,\n        comment=comment,\n        session=session,\n        allow_disk_use=allow_disk_use,\n    )\n    inst_model_dict = {key: val for key, val in cls().__dict__.items() if not callable(val) and not val.ignored}\n    lang = translations.CURRENT_LOCALE\n    async for mongo_doc in cursor:\n        doc_list.append(\n            mongo_doc_to_raw_doc(\n                inst_model_dict,\n                mongo_doc,\n                lang,\n            ),\n        )\n    return orjson.dumps(doc_list).decode(\"utf-8\") if len(doc_list) &gt; 0 else None\n</code></pre>"},{"location":"pages/commons/many/#ramifice.commons.many.ManyMixin.find_many_to_raw_docs","title":"<code>find_many_to_raw_docs(filter=None, projection=None, skip=0, limit=0, no_cursor_timeout=False, cursor_type=CursorType.NON_TAILABLE, sort=None, allow_partial_results=False, oplog_replay=False, batch_size=0, collation=None, hint=None, max_scan=None, max_time_ms=None, max=None, min=None, return_key=False, show_record_id=False, comment=None, session=None, allow_disk_use=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Find documents and convert to a raw documents.</p> Special changes <p>_id to str password to None date to str datetime to str</p> Source code in <code>src/ramifice/commons/many.py</code> <pre><code>@classmethod\nasync def find_many_to_raw_docs(\n    cls,\n    filter: Any | None = None,\n    projection: Any | None = None,\n    skip: int = 0,\n    limit: int = 0,\n    no_cursor_timeout: bool = False,\n    cursor_type: int = CursorType.NON_TAILABLE,\n    sort: Any | None = None,\n    allow_partial_results: bool = False,\n    oplog_replay: bool = False,\n    batch_size: int = 0,\n    collation: Any | None = None,\n    hint: Any | None = None,\n    max_scan: Any | None = None,\n    max_time_ms: Any | None = None,\n    max: Any | None = None,\n    min: Any | None = None,\n    return_key: bool = False,\n    show_record_id: bool = False,\n    comment: Any | None = None,\n    session: Any | None = None,\n    allow_disk_use: Any | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Find documents and convert to a raw documents.\n\n    Special changes:\n        _id to str\n        password to None\n        date to str\n        datetime to str\n    \"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get documents.\n    doc_list: list[dict[str, Any]] = []\n    cursor: AsyncCursor = collection.find(\n        filter=filter,\n        projection=projection,\n        skip=skip,\n        limit=limit or cls.META[\"db_query_docs_limit\"],\n        no_cursor_timeout=no_cursor_timeout,\n        cursor_type=cursor_type,\n        sort=sort,\n        allow_partial_results=allow_partial_results,\n        oplog_replay=oplog_replay,\n        batch_size=batch_size,\n        collation=collation,\n        hint=hint,\n        max_scan=max_scan,\n        max_time_ms=max_time_ms,\n        max=max,\n        min=min,\n        return_key=return_key,\n        show_record_id=show_record_id,\n        comment=comment,\n        session=session,\n        allow_disk_use=allow_disk_use,\n    )\n    inst_model_dict = {key: val for key, val in cls().__dict__.items() if not callable(val) and not val.ignored}\n    lang = translations.CURRENT_LOCALE\n    async for mongo_doc in cursor:\n        doc_list.append(\n            mongo_doc_to_raw_doc(\n                inst_model_dict,\n                mongo_doc,\n                lang,\n            ),\n        )\n    return doc_list\n</code></pre>"},{"location":"pages/commons/one/","title":"One","text":"<p>Requests like <code>find one</code>.</p>"},{"location":"pages/commons/one/#ramifice.commons.one.OneMixin","title":"<code>OneMixin</code>","text":"<p>Requests like <code>find one</code>.</p> Source code in <code>src/ramifice/commons/one.py</code> <pre><code>class OneMixin:\n    \"\"\"Requests like `find one`.\"\"\"\n\n    @classmethod\n    async def find_one(\n        cls: Any,\n        filter: Any | None = None,\n        *args: tuple,\n        **kwargs: dict[str, Any],\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Get a single document from the database.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get document.\n        mongo_doc = await collection.find_one(filter, *args, **kwargs)\n        if mongo_doc is not None:\n            mongo_doc = password_to_none(\n                cls.META[\"field_name_and_type\"],\n                mongo_doc,\n            )\n        return mongo_doc\n\n    @classmethod\n    async def find_one_to_raw_doc(\n        cls: Any,\n        filter: Any | None = None,\n        *args: tuple,\n        **kwargs: dict[str, Any],\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Find a single document and converting to raw document.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get document.\n        raw_doc = None\n        mongo_doc = await collection.find_one(filter, *args, **kwargs)\n        inst_model_dict = {key: val for key, val in cls().__dict__.items() if not callable(val) and not val.ignored}\n        if mongo_doc is not None:\n            raw_doc = mongo_doc_to_raw_doc(\n                inst_model_dict,\n                mongo_doc,\n                translations.CURRENT_LOCALE,\n            )\n        return raw_doc\n\n    @classmethod\n    async def find_one_to_instance(\n        cls: Any,\n        filter: Any | None = None,\n        *args: tuple,\n        **kwargs: dict[str, Any],\n    ) -&gt; Any | None:\n        \"\"\"Find a single document and convert it to a Model instance.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get document.\n        inst_model = None\n        mongo_doc = await collection.find_one(filter, *args, **kwargs)\n        if mongo_doc is not None:\n            # Convert document to Model instance.\n            inst_model = cls.from_mongo_doc(mongo_doc)\n        return inst_model\n\n    @classmethod\n    async def find_one_to_json(\n        cls: Any,\n        filter: Any | None = None,\n        *args: tuple,\n        **kwargs: dict[str, Any],\n    ) -&gt; str | None:\n        \"\"\"Find a single document and convert it to a JSON string.\"\"\"\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get document.\n        json_str: str | None = None\n        mongo_doc = await collection.find_one(filter, *args, **kwargs)\n        if mongo_doc is not None:\n            # Convert document to Model instance.\n            inst_model = cls.from_mongo_doc(mongo_doc)\n            json_str = inst_model.to_json()\n        return json_str\n\n    @classmethod\n    async def delete_one(\n        cls: Any,\n        filter: Any,\n        collation: Any | None = None,\n        hint: Any | None = None,\n        session: Any | None = None,\n        let: Any | None = None,\n        comment: Any | None = None,\n    ) -&gt; DeleteResult:\n        \"\"\"Delete a single document matching the filter.\"\"\"\n        # Raises a panic if the Model cannot be removed.\n        if not cls.META[\"is_delete_doc\"]:\n            msg = (\n                f\"Model: `{cls.META['full_model_name']}` &gt; \"\n                + \"META param: `is_delete_doc` (False) =&gt; \"\n                + \"Documents of this Model cannot be removed from the database!\"\n            )\n            logger.error(msg)\n            raise ForbiddenDeleteDocError(msg)\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get document.\n        result: DeleteResult = await collection.delete_one(\n            filter=filter,\n            collation=collation,\n            hint=hint,\n            session=session,\n            let=let,\n            comment=comment,\n        )\n        return result\n\n    @classmethod\n    async def find_one_and_delete(\n        cls: Any,\n        filter: Any,\n        projection: Any | None = None,\n        sort: Any | None = None,\n        hint: Any | None = None,\n        session: Any | None = None,\n        let: Any | None = None,\n        comment: Any | None = None,\n        **kwargs: dict[str, Any],\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Finds a single document and deletes it, returning the document.\"\"\"\n        # Raises a panic if the Model cannot be removed.\n        if not cls.META[\"is_delete_doc\"]:\n            msg = (\n                f\"Model: `{cls.META['full_model_name']}` &gt; \"\n                + \"META param: `is_delete_doc` (False) =&gt; \"\n                + \"Documents of this Model cannot be removed from the database!\"\n            )\n            logger.error(msg)\n            raise ForbiddenDeleteDocError(msg)\n        # Get collection for current model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        # Correcting filter.\n        if filter is not None:\n            filter = correct_mongo_filter(cls, filter)\n        # Get document.\n        mongo_doc: dict[str, Any] | None = await collection.find_one_and_delete(\n            filter=filter,\n            projection=projection,\n            sort=sort,\n            hint=hint,\n            session=session,\n            let=let,\n            comment=comment,\n            **kwargs,\n        )\n        if mongo_doc is not None:\n            mongo_doc = password_to_none(\n                cls.META[\"field_name_and_type\"],\n                mongo_doc,\n            )\n        return mongo_doc\n</code></pre>"},{"location":"pages/commons/one/#ramifice.commons.one.OneMixin.delete_one","title":"<code>delete_one(filter, collation=None, hint=None, session=None, let=None, comment=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Delete a single document matching the filter.</p> Source code in <code>src/ramifice/commons/one.py</code> <pre><code>@classmethod\nasync def delete_one(\n    cls: Any,\n    filter: Any,\n    collation: Any | None = None,\n    hint: Any | None = None,\n    session: Any | None = None,\n    let: Any | None = None,\n    comment: Any | None = None,\n) -&gt; DeleteResult:\n    \"\"\"Delete a single document matching the filter.\"\"\"\n    # Raises a panic if the Model cannot be removed.\n    if not cls.META[\"is_delete_doc\"]:\n        msg = (\n            f\"Model: `{cls.META['full_model_name']}` &gt; \"\n            + \"META param: `is_delete_doc` (False) =&gt; \"\n            + \"Documents of this Model cannot be removed from the database!\"\n        )\n        logger.error(msg)\n        raise ForbiddenDeleteDocError(msg)\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get document.\n    result: DeleteResult = await collection.delete_one(\n        filter=filter,\n        collation=collation,\n        hint=hint,\n        session=session,\n        let=let,\n        comment=comment,\n    )\n    return result\n</code></pre>"},{"location":"pages/commons/one/#ramifice.commons.one.OneMixin.find_one","title":"<code>find_one(filter=None, *args, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Get a single document from the database.</p> Source code in <code>src/ramifice/commons/one.py</code> <pre><code>@classmethod\nasync def find_one(\n    cls: Any,\n    filter: Any | None = None,\n    *args: tuple,\n    **kwargs: dict[str, Any],\n) -&gt; dict[str, Any] | None:\n    \"\"\"Get a single document from the database.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get document.\n    mongo_doc = await collection.find_one(filter, *args, **kwargs)\n    if mongo_doc is not None:\n        mongo_doc = password_to_none(\n            cls.META[\"field_name_and_type\"],\n            mongo_doc,\n        )\n    return mongo_doc\n</code></pre>"},{"location":"pages/commons/one/#ramifice.commons.one.OneMixin.find_one_and_delete","title":"<code>find_one_and_delete(filter, projection=None, sort=None, hint=None, session=None, let=None, comment=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Finds a single document and deletes it, returning the document.</p> Source code in <code>src/ramifice/commons/one.py</code> <pre><code>@classmethod\nasync def find_one_and_delete(\n    cls: Any,\n    filter: Any,\n    projection: Any | None = None,\n    sort: Any | None = None,\n    hint: Any | None = None,\n    session: Any | None = None,\n    let: Any | None = None,\n    comment: Any | None = None,\n    **kwargs: dict[str, Any],\n) -&gt; dict[str, Any] | None:\n    \"\"\"Finds a single document and deletes it, returning the document.\"\"\"\n    # Raises a panic if the Model cannot be removed.\n    if not cls.META[\"is_delete_doc\"]:\n        msg = (\n            f\"Model: `{cls.META['full_model_name']}` &gt; \"\n            + \"META param: `is_delete_doc` (False) =&gt; \"\n            + \"Documents of this Model cannot be removed from the database!\"\n        )\n        logger.error(msg)\n        raise ForbiddenDeleteDocError(msg)\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get document.\n    mongo_doc: dict[str, Any] | None = await collection.find_one_and_delete(\n        filter=filter,\n        projection=projection,\n        sort=sort,\n        hint=hint,\n        session=session,\n        let=let,\n        comment=comment,\n        **kwargs,\n    )\n    if mongo_doc is not None:\n        mongo_doc = password_to_none(\n            cls.META[\"field_name_and_type\"],\n            mongo_doc,\n        )\n    return mongo_doc\n</code></pre>"},{"location":"pages/commons/one/#ramifice.commons.one.OneMixin.find_one_to_instance","title":"<code>find_one_to_instance(filter=None, *args, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Find a single document and convert it to a Model instance.</p> Source code in <code>src/ramifice/commons/one.py</code> <pre><code>@classmethod\nasync def find_one_to_instance(\n    cls: Any,\n    filter: Any | None = None,\n    *args: tuple,\n    **kwargs: dict[str, Any],\n) -&gt; Any | None:\n    \"\"\"Find a single document and convert it to a Model instance.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get document.\n    inst_model = None\n    mongo_doc = await collection.find_one(filter, *args, **kwargs)\n    if mongo_doc is not None:\n        # Convert document to Model instance.\n        inst_model = cls.from_mongo_doc(mongo_doc)\n    return inst_model\n</code></pre>"},{"location":"pages/commons/one/#ramifice.commons.one.OneMixin.find_one_to_json","title":"<code>find_one_to_json(filter=None, *args, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Find a single document and convert it to a JSON string.</p> Source code in <code>src/ramifice/commons/one.py</code> <pre><code>@classmethod\nasync def find_one_to_json(\n    cls: Any,\n    filter: Any | None = None,\n    *args: tuple,\n    **kwargs: dict[str, Any],\n) -&gt; str | None:\n    \"\"\"Find a single document and convert it to a JSON string.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get document.\n    json_str: str | None = None\n    mongo_doc = await collection.find_one(filter, *args, **kwargs)\n    if mongo_doc is not None:\n        # Convert document to Model instance.\n        inst_model = cls.from_mongo_doc(mongo_doc)\n        json_str = inst_model.to_json()\n    return json_str\n</code></pre>"},{"location":"pages/commons/one/#ramifice.commons.one.OneMixin.find_one_to_raw_doc","title":"<code>find_one_to_raw_doc(filter=None, *args, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Find a single document and converting to raw document.</p> Source code in <code>src/ramifice/commons/one.py</code> <pre><code>@classmethod\nasync def find_one_to_raw_doc(\n    cls: Any,\n    filter: Any | None = None,\n    *args: tuple,\n    **kwargs: dict[str, Any],\n) -&gt; dict[str, Any] | None:\n    \"\"\"Find a single document and converting to raw document.\"\"\"\n    # Get collection for current model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n    # Correcting filter.\n    if filter is not None:\n        filter = correct_mongo_filter(cls, filter)\n    # Get document.\n    raw_doc = None\n    mongo_doc = await collection.find_one(filter, *args, **kwargs)\n    inst_model_dict = {key: val for key, val in cls().__dict__.items() if not callable(val) and not val.ignored}\n    if mongo_doc is not None:\n        raw_doc = mongo_doc_to_raw_doc(\n            inst_model_dict,\n            mongo_doc,\n            translations.CURRENT_LOCALE,\n        )\n    return raw_doc\n</code></pre>"},{"location":"pages/commons/tools/","title":"Tools","text":"<p>Tool of Commons - A set of auxiliary methods.</p>"},{"location":"pages/commons/tools/#ramifice.commons.tools.correct_mongo_filter","title":"<code>correct_mongo_filter(cls_model, filter)</code>","text":"<p>Correcting filter of request.</p> <p>Corrects <code>TextField</code> fields that require localization of translation.</p> Source code in <code>src/ramifice/commons/tools.py</code> <pre><code>def correct_mongo_filter(cls_model: Any, filter: Any) -&gt; Any:\n    \"\"\"Correcting filter of request.\n\n    Corrects `TextField` fields that require localization of translation.\n    \"\"\"\n    lang: str = translations.CURRENT_LOCALE\n    filter_json: str = json_util.dumps(filter)\n    filter_json = cls_model.META[\"regex_mongo_filter\"].sub(rf'\\g&lt;field&gt;.{lang}\":', filter_json).replace('\":.', \".\")\n    return json_util.loads(filter_json)\n</code></pre>"},{"location":"pages/commons/tools/#ramifice.commons.tools.mongo_doc_to_raw_doc","title":"<code>mongo_doc_to_raw_doc(inst_model_dict, mongo_doc, lang)</code>","text":"<p>Convert the Mongo document to the raw document.</p> Special changes <ul> <li><code>_id to str</code></li> <li><code>password to None</code></li> <li><code>date to str</code></li> <li><code>datetime to str</code></li> </ul> Source code in <code>src/ramifice/commons/tools.py</code> <pre><code>def mongo_doc_to_raw_doc(\n    inst_model_dict: dict[str, Any],\n    mongo_doc: dict[str, Any],\n    lang: str,\n) -&gt; dict[str, Any]:\n    \"\"\"Convert the Mongo document to the raw document.\n\n    Special changes:\n        - `_id to str`\n        - `password to None`\n        - `date to str`\n        - `datetime to str`\n    \"\"\"\n    doc: dict[str, Any] = {}\n    for f_name, f_data in inst_model_dict.items():\n        field_type = f_data.field_type\n        value = mongo_doc[f_name]\n        if value is not None:\n            if field_type == \"TextField\" and f_data.multi_language:\n                value = value.get(lang, \"- -\") if value is not None else None\n            elif \"Date\" in field_type:\n                if \"Time\" in field_type:\n                    value = format_datetime(\n                        datetime=value,\n                        format=\"short\",\n                        locale=lang,\n                    )\n                else:\n                    value = format_date(\n                        date=value.date(),\n                        format=\"short\",\n                        locale=lang,\n                    )\n            elif field_type == \"IDField\":\n                value = str(value)\n            elif field_type == \"PasswordField\":\n                value = None\n        doc[f_name] = value\n    return doc\n</code></pre>"},{"location":"pages/commons/tools/#ramifice.commons.tools.password_to_none","title":"<code>password_to_none(field_name_and_type, mongo_doc)</code>","text":"<p>Create object instance from Mongo document.</p> Source code in <code>src/ramifice/commons/tools.py</code> <pre><code>def password_to_none(\n    field_name_and_type: dict[str, str],\n    mongo_doc: dict[str, Any],\n) -&gt; dict[str, Any]:\n    \"\"\"Create object instance from Mongo document.\"\"\"\n    for f_name, t_name in field_name_and_type.items():\n        if t_name == \"PasswordField\":\n            mongo_doc[f_name] = None\n    return mongo_doc\n</code></pre>"},{"location":"pages/commons/unit_manager/","title":"Unit Manager","text":"<p>Units Management.</p> <p>Management for <code>choices</code> parameter in dynamic field types.</p>"},{"location":"pages/commons/unit_manager/#ramifice.commons.unit_manager.UnitMixin","title":"<code>UnitMixin</code>","text":"<p>Units Management.</p> <p>Management for <code>choices</code> parameter in dynamic field types.</p> Source code in <code>src/ramifice/commons/unit_manager.py</code> <pre><code>class UnitMixin:\n    \"\"\"Units Management.\n\n    Management for `choices` parameter in dynamic field types.\n    \"\"\"\n\n    @classmethod\n    async def unit_manager(cls: Any, unit: Unit) -&gt; None:\n        \"\"\"Units Management.\n\n        Management for `choices` parameter in dynamic field types.\n        \"\"\"\n        # Get access to super collection.\n        # (Contains Model state and dynamic field data.)\n        super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n        # Get Model state.\n        model_state: dict[str, Any] | None = await super_collection.find_one(\n            filter={\"collection_name\": cls.META[\"collection_name\"]},\n        )\n        # Check the presence of a Model state.\n        if model_state is None:\n            msg = \"Error: Model State - Not found!\"\n            logger.critical(msg)\n            raise PanicError(msg)\n        # Get language list.\n        lang_list = translations.LANGUAGES\n        # Get clean fields of Unit.\n        unit_field: str = unit.field\n        title = unit.title\n        if len(title) != len(lang_list):\n            msg = \"Unit.title =&gt; There are no translations for some languages!\"\n            logger.critical(msg)\n            raise PanicError(msg)\n        title = {lang: title[lang] for lang in lang_list}\n        target_value = unit.value\n        # Get dynamic field data.\n        choices: list | None = model_state[\"data_dynamic_fields\"][unit_field]\n        # Determine the presence of unit.\n        is_unit_exists: bool = False\n        if choices is not None:\n            for item in choices:\n                if item[\"value\"] == target_value:\n                    is_unit_exists = True\n                    break\n        # Add Unit to Model State.\n        if not unit.is_delete:\n            if choices is not None:\n                if is_unit_exists:\n                    main_lang = translations.DEFAULT_LOCALE\n                    msg = (\n                        \"Error: It is not possible to add Unit - \"\n                        + f\"Unit `{title[main_lang]}: {target_value}` is exists!\"\n                    )\n                    logger.error(msg)\n                    raise NotPossibleAddUnitError(msg)\n                choices.append({\"title\": title, \"value\": target_value})\n            else:\n                choices = [{\"title\": title, \"value\": target_value}]\n            model_state[\"data_dynamic_fields\"][unit_field] = choices\n        else:\n            # Delete Unit from Model State.\n            if choices is None:\n                msg = \"Error: It is not possible to delete Unit - Units is not exists!\"\n                logger.error(msg)\n                raise NotPossibleDeleteUnitError(msg)\n            if not is_unit_exists:\n                main_lang = translations.DEFAULT_LOCALE\n                msg = (\n                    \"Error: It is not possible to delete Unit.\"\n                    + f\"Unit `{title[main_lang]}: {target_value}` is not exists!\"\n                )\n                logger.erro(msg)\n                raise NotPossibleDeleteUnitError(msg)\n            choices = [item for item in choices if item[\"value\"] != target_value]\n            model_state[\"data_dynamic_fields\"][unit_field] = choices or None\n        # Update state of current Model in super collection.\n        await super_collection.replace_one(\n            filter={\"collection_name\": model_state[\"collection_name\"]},\n            replacement=model_state,\n        )\n        # Update metadata of current Model.\n        cls.META[\"data_dynamic_fields\"][unit_field] = choices or None\n        # Update documents in the collection of the current Model.\n        if unit.is_delete:\n            collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n            async for mongo_doc in collection.find():\n                field_value = mongo_doc[unit_field]\n                if field_value is not None:\n                    if isinstance(field_value, list):\n                        value_list = mongo_doc[unit_field]\n                        value_list.remove(target_value)\n                        mongo_doc[unit_field] = value_list or None\n                    else:\n                        mongo_doc[unit_field] = None\n                await collection.replace_one(\n                    filter={\"_id\": mongo_doc[\"_id\"]},\n                    replacement=mongo_doc,\n                )\n</code></pre>"},{"location":"pages/commons/unit_manager/#ramifice.commons.unit_manager.UnitMixin.unit_manager","title":"<code>unit_manager(unit)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Units Management.</p> <p>Management for <code>choices</code> parameter in dynamic field types.</p> Source code in <code>src/ramifice/commons/unit_manager.py</code> <pre><code>@classmethod\nasync def unit_manager(cls: Any, unit: Unit) -&gt; None:\n    \"\"\"Units Management.\n\n    Management for `choices` parameter in dynamic field types.\n    \"\"\"\n    # Get access to super collection.\n    # (Contains Model state and dynamic field data.)\n    super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n    # Get Model state.\n    model_state: dict[str, Any] | None = await super_collection.find_one(\n        filter={\"collection_name\": cls.META[\"collection_name\"]},\n    )\n    # Check the presence of a Model state.\n    if model_state is None:\n        msg = \"Error: Model State - Not found!\"\n        logger.critical(msg)\n        raise PanicError(msg)\n    # Get language list.\n    lang_list = translations.LANGUAGES\n    # Get clean fields of Unit.\n    unit_field: str = unit.field\n    title = unit.title\n    if len(title) != len(lang_list):\n        msg = \"Unit.title =&gt; There are no translations for some languages!\"\n        logger.critical(msg)\n        raise PanicError(msg)\n    title = {lang: title[lang] for lang in lang_list}\n    target_value = unit.value\n    # Get dynamic field data.\n    choices: list | None = model_state[\"data_dynamic_fields\"][unit_field]\n    # Determine the presence of unit.\n    is_unit_exists: bool = False\n    if choices is not None:\n        for item in choices:\n            if item[\"value\"] == target_value:\n                is_unit_exists = True\n                break\n    # Add Unit to Model State.\n    if not unit.is_delete:\n        if choices is not None:\n            if is_unit_exists:\n                main_lang = translations.DEFAULT_LOCALE\n                msg = (\n                    \"Error: It is not possible to add Unit - \"\n                    + f\"Unit `{title[main_lang]}: {target_value}` is exists!\"\n                )\n                logger.error(msg)\n                raise NotPossibleAddUnitError(msg)\n            choices.append({\"title\": title, \"value\": target_value})\n        else:\n            choices = [{\"title\": title, \"value\": target_value}]\n        model_state[\"data_dynamic_fields\"][unit_field] = choices\n    else:\n        # Delete Unit from Model State.\n        if choices is None:\n            msg = \"Error: It is not possible to delete Unit - Units is not exists!\"\n            logger.error(msg)\n            raise NotPossibleDeleteUnitError(msg)\n        if not is_unit_exists:\n            main_lang = translations.DEFAULT_LOCALE\n            msg = (\n                \"Error: It is not possible to delete Unit.\"\n                + f\"Unit `{title[main_lang]}: {target_value}` is not exists!\"\n            )\n            logger.erro(msg)\n            raise NotPossibleDeleteUnitError(msg)\n        choices = [item for item in choices if item[\"value\"] != target_value]\n        model_state[\"data_dynamic_fields\"][unit_field] = choices or None\n    # Update state of current Model in super collection.\n    await super_collection.replace_one(\n        filter={\"collection_name\": model_state[\"collection_name\"]},\n        replacement=model_state,\n    )\n    # Update metadata of current Model.\n    cls.META[\"data_dynamic_fields\"][unit_field] = choices or None\n    # Update documents in the collection of the current Model.\n    if unit.is_delete:\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls.META[\"collection_name\"]]\n        async for mongo_doc in collection.find():\n            field_value = mongo_doc[unit_field]\n            if field_value is not None:\n                if isinstance(field_value, list):\n                    value_list = mongo_doc[unit_field]\n                    value_list.remove(target_value)\n                    mongo_doc[unit_field] = value_list or None\n                else:\n                    mongo_doc[unit_field] = None\n            await collection.replace_one(\n                filter={\"_id\": mongo_doc[\"_id\"]},\n                replacement=mongo_doc,\n            )\n</code></pre>"},{"location":"pages/fields/","title":"Fields","text":"<p>Available field types.</p>"},{"location":"pages/fields/bool_field/","title":"BooleanField","text":"<p>Field of Model for enter boolean value.</p>"},{"location":"pages/fields/bool_field/#ramifice.fields.bool_field.BooleanField","title":"<code>BooleanField</code>","text":"<p>               Bases: <code>Field</code>, <code>JsonMixin</code></p> <p>Field of Model for enter boolean value.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> Source code in <code>src/ramifice/fields/bool_field.py</code> <pre><code>class BooleanField(Field, JsonMixin):\n    \"\"\"Field of Model for enter boolean value.\n\n    Args:\n        label: Text label for a web form field.\n        default: Default value.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        default: bool = False,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None and not isinstance(default, bool):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `bool` type!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"BooleanField\",\n            group=\"bool\",\n        )\n        JsonMixin.__init__(self)\n\n        self.input_type = \"checkbox\"\n        self.value: bool | None = None\n        self.default = default\n</code></pre>"},{"location":"pages/fields/choice_float_dyn_field/","title":"ChoiceFloatDynField","text":"<p>Field of Model.</p> <p>Type of selective float field with dynamic addition of elements.</p>"},{"location":"pages/fields/choice_float_dyn_field/#ramifice.fields.choice_float_dyn_field.ChoiceFloatDynField","title":"<code>ChoiceFloatDynField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective integer field with dynamic addition of elements. For simulate relationship Many-to-One. Element are (add|delete) via <code>ModelName.unit_manager(unit)</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> Source code in <code>src/ramifice/fields/choice_float_dyn_field.py</code> <pre><code>class ChoiceFloatDynField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective integer field with dynamic addition of elements.\n    For simulate relationship Many-to-One.\n    Element are (add|delete) via `ModelName.unit_manager(unit)` method.\n\n    Args:\n        label: Text label for a web form field.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceFloatDynField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: float | None = None\n        self.choices: list[list[float | str]] | None = None\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        if is_migrate:\n            return True\n        value = self.value\n        if value is not None:\n            choices = self.choices\n            if not bool(choices):\n                return False\n            if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n                return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_float_dyn_field/#ramifice.fields.choice_float_dyn_field.ChoiceFloatDynField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_float_dyn_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    if is_migrate:\n        return True\n    value = self.value\n    if value is not None:\n        choices = self.choices\n        if not bool(choices):\n            return False\n        if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n            return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_float_field/","title":"ChoiceFloatField","text":"<p>Field of Model.</p> <p>Type of selective float field with static of elements.</p>"},{"location":"pages/fields/choice_float_field/#ramifice.fields.choice_float_field.ChoiceFloatField","title":"<code>ChoiceFloatField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective integer float with static of elements. With a single choice.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>default</code> <code>float | None</code> <p>Default value.</p> <code>None</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>choices</code> <code>list[list[float | str]] | None</code> <p>For a predefined set of options - [[value, Title], ...].</p> <code>None</code> Source code in <code>src/ramifice/fields/choice_float_field.py</code> <pre><code>class ChoiceFloatField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective integer float with static of elements.\n    With a single choice.\n\n    Args:\n        label: Text label for a web form field.\n        default: Default value.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        choices: For a predefined set of options - [[value, Title], ...].\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        default: float | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        choices: list[list[float | str]] | None = None,  # [[value, Title], ...]\n    ) -&gt; None:\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceFloatField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: float | None = None\n        self.default = default\n        self.choices = choices\n\n        if constants.DEBUG:\n            try:\n                if choices is not None:\n                    if not isinstance(choices, list):\n                        raise AssertionError(\"Parameter `choices` - Not \u0430 `list` type!\")\n                    if len(choices) == 0:\n                        raise AssertionError(\"The `choices` parameter should not contain an empty list!\")\n                if default is not None and not isinstance(default, float):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `float` type!\")\n                if default is not None and choices is not None and not self.has_value():\n                    raise AssertionError(\n                        \"Parameter `default` does not coincide with \" + \"list of permissive values in `choicees`.\",\n                    )\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        value = self.value\n        if value is None:\n            value = self.default\n        if value is not None:\n            choices = self.choices\n            if not bool(choices):\n                return False\n            if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n                return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_float_field/#ramifice.fields.choice_float_field.ChoiceFloatField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_float_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    value = self.value\n    if value is None:\n        value = self.default\n    if value is not None:\n        choices = self.choices\n        if not bool(choices):\n            return False\n        if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n            return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_float_mult_dyn_field/","title":"ChoiceFloatMultDynField","text":"<p>Field of Model.</p> <p>Type of selective float field with dynamic addition of elements.</p>"},{"location":"pages/fields/choice_float_mult_dyn_field/#ramifice.fields.choice_float_mult_dyn_field.ChoiceFloatMultDynField","title":"<code>ChoiceFloatMultDynField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective float field with dynamic addition of elements. For simulate relationship Many-to-Many.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> Source code in <code>src/ramifice/fields/choice_float_mult_dyn_field.py</code> <pre><code>class ChoiceFloatMultDynField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective float field with dynamic addition of elements.\n    For simulate relationship Many-to-Many.\n\n    Args:\n        label: Text label for a web form field.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceFloatMultDynField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n            multiple=True,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: list[float] | None = None\n        self.choices: list[list[float | str]] | None = None\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        if is_migrate:\n            return True\n        value = self.value\n        if value is not None:\n            choices = self.choices\n            if len(value) == 0 or not bool(choices):\n                return False\n            value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n            for item in value:\n                if item not in value_list:\n                    return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_float_mult_dyn_field/#ramifice.fields.choice_float_mult_dyn_field.ChoiceFloatMultDynField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_float_mult_dyn_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    if is_migrate:\n        return True\n    value = self.value\n    if value is not None:\n        choices = self.choices\n        if len(value) == 0 or not bool(choices):\n            return False\n        value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n        for item in value:\n            if item not in value_list:\n                return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_float_mult_field/","title":"ChoiceFloatMultField","text":"<p>Field of Model.</p> <p>Type of selective float field with static of elements.</p>"},{"location":"pages/fields/choice_float_mult_field/#ramifice.fields.choice_float_mult_field.ChoiceFloatMultField","title":"<code>ChoiceFloatMultField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective float field with static of elements. With multiple choice.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>default</code> <code>list[float] | None</code> <p>Default value.</p> <code>None</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> <code>choices</code> <code>list[list[float | str]] | None</code> <p>For a predefined set of options - [[value, Title], ...].</p> <code>None</code> Source code in <code>src/ramifice/fields/choice_float_mult_field.py</code> <pre><code>class ChoiceFloatMultField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective float field with static of elements.\n    With multiple choice.\n\n    Args:\n        label: Text label for a web form field.\n        default: Default value.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        choices: For a predefined set of options - [[value, Title], ...].\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        default: list[float] | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        choices: list[list[float | str]] | None = None,  # [[value, Title], ...]\n    ) -&gt; None:\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceFloatMultField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n            multiple=True,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: list[float] | None = None\n        self.default = default\n        self.choices = choices\n\n        if constants.DEBUG:\n            try:\n                if choices is not None:\n                    if not isinstance(choices, list):\n                        raise AssertionError(\"Parameter `choices` - Not \u0430 `list` type!\")\n                    if len(choices) == 0:\n                        raise AssertionError(\"The `choices` parameter should not contain an empty list!\")\n                if default is not None:\n                    if not isinstance(default, list):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `list` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty list!\")\n                    if choices is not None and not self.has_value():\n                        raise AssertionError(\n                            \"Parameter `default` does not coincide with \" + \"list of permissive values in `choicees`.\",\n                        )\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        value = self.value\n        if value is None:\n            value = self.default\n        if value is not None:\n            choices = self.choices\n            if len(value) == 0 or not bool(choices):\n                return False\n            value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n            for item in value:\n                if item not in value_list:\n                    return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_float_mult_field/#ramifice.fields.choice_float_mult_field.ChoiceFloatMultField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_float_mult_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    value = self.value\n    if value is None:\n        value = self.default\n    if value is not None:\n        choices = self.choices\n        if len(value) == 0 or not bool(choices):\n            return False\n        value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n        for item in value:\n            if item not in value_list:\n                return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_int_dyn_field/","title":"ChoiceIntDynField","text":"<p>Field of Model.</p> <p>Type of selective integer field with dynamic addition of elements.</p>"},{"location":"pages/fields/choice_int_dyn_field/#ramifice.fields.choice_int_dyn_field.ChoiceIntDynField","title":"<code>ChoiceIntDynField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective integer field with dynamic addition of elements. For simulate relationship Many-to-One. Element are (add|delete) via <code>ModelName.unit_manager(unit)</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> Source code in <code>src/ramifice/fields/choice_int_dyn_field.py</code> <pre><code>class ChoiceIntDynField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective integer field with dynamic addition of elements.\n    For simulate relationship Many-to-One.\n    Element are (add|delete) via `ModelName.unit_manager(unit)` method.\n\n    Args:\n        label: Text label for a web form field.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceIntDynField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: int | None = None\n        self.choices: list[list[int | str]] | None = None\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        if is_migrate:\n            return True\n        value = self.value\n        if value is not None:\n            choices = self.choices\n            if not bool(choices):\n                return False\n            if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n                return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_int_dyn_field/#ramifice.fields.choice_int_dyn_field.ChoiceIntDynField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_int_dyn_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    if is_migrate:\n        return True\n    value = self.value\n    if value is not None:\n        choices = self.choices\n        if not bool(choices):\n            return False\n        if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n            return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_int_field/","title":"ChoiceIntField","text":"<p>Field of Model.</p> <p>Type of selective integer field with static of elements.</p>"},{"location":"pages/fields/choice_int_field/#ramifice.fields.choice_int_field.ChoiceIntField","title":"<code>ChoiceIntField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective integer field with static of elements. With a single choice.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>default</code> <code>int | None</code> <p>Default value.</p> <code>None</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>choices</code> <code>list[list[int | str]] | None</code> <p>For a predefined set of options - [[value, Title], ...].</p> <code>None</code> Source code in <code>src/ramifice/fields/choice_int_field.py</code> <pre><code>class ChoiceIntField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective integer field with static of elements.\n    With a single choice.\n\n    Args:\n        label: Text label for a web form field.\n        default: Default value.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        choices: For a predefined set of options - [[value, Title], ...].\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        default: int | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        choices: list[list[int | str]] | None = None,  # [[value, Title], ...]\n    ) -&gt; None:\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceIntField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: int | None = None\n        self.default = default\n        self.choices = choices\n\n        if constants.DEBUG:\n            try:\n                if choices is not None:\n                    if not isinstance(choices, list):\n                        raise AssertionError(\"Parameter `choices` - Not \u0430 `list` type!\")\n                    if len(choices) == 0:\n                        raise AssertionError(\"The `choices` parameter should not contain an empty list!\")\n                if default is not None and not isinstance(default, int):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if default is not None and choices is not None and not self.has_value():\n                    raise AssertionError(\n                        \"Parameter `default` does not coincide with \" + \"list of permissive values in `choicees`.\",\n                    )\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        value = self.value\n        if value is None:\n            value = self.default\n        if value is not None:\n            choices = self.choices\n            if not bool(choices):\n                return False\n            if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n                return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_int_field/#ramifice.fields.choice_int_field.ChoiceIntField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_int_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    value = self.value\n    if value is None:\n        value = self.default\n    if value is not None:\n        choices = self.choices\n        if not bool(choices):\n            return False\n        if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n            return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_int_mult_dyn_field/","title":"ChoiceIntMultDynField","text":"<p>Field of Model.</p> <p>Type of selective integer field with dynamic addition of elements.</p>"},{"location":"pages/fields/choice_int_mult_dyn_field/#ramifice.fields.choice_int_mult_dyn_field.ChoiceIntMultDynField","title":"<code>ChoiceIntMultDynField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective integer field with dynamic addition of elements. For simulate relationship Many-to-Many.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> Source code in <code>src/ramifice/fields/choice_int_mult_dyn_field.py</code> <pre><code>class ChoiceIntMultDynField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective integer field with dynamic addition of elements.\n    For simulate relationship Many-to-Many.\n\n    Args:\n        label: Text label for a web form field.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceIntMultDynField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n            multiple=True,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: list[int] | None = None\n        self.choices: list[list[int | str]] | None = None\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        if is_migrate:\n            return True\n        value = self.value\n        if value is not None:\n            choices = self.choices\n            if len(value) == 0 or not bool(choices):\n                return False\n            value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n            for item in value:\n                if item not in value_list:\n                    return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_int_mult_dyn_field/#ramifice.fields.choice_int_mult_dyn_field.ChoiceIntMultDynField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_int_mult_dyn_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    if is_migrate:\n        return True\n    value = self.value\n    if value is not None:\n        choices = self.choices\n        if len(value) == 0 or not bool(choices):\n            return False\n        value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n        for item in value:\n            if item not in value_list:\n                return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_int_mult_field/","title":"ChoiceIntMultField","text":"<p>Field of Model.</p> <p>Type of selective integer field with static of elements.</p>"},{"location":"pages/fields/choice_int_mult_field/#ramifice.fields.choice_int_mult_field.ChoiceIntMultField","title":"<code>ChoiceIntMultField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective integer field with static of elements. With multiple choice.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>default</code> <code>list[int] | None</code> <p>Default value.</p> <code>None</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> <code>choices</code> <code>list[list[int | str]] | None</code> <p>For a predefined set of options - [[value, Title], ...].</p> <code>None</code> Source code in <code>src/ramifice/fields/choice_int_mult_field.py</code> <pre><code>class ChoiceIntMultField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective integer field with static of elements.\n    With multiple choice.\n\n    Args:\n        label: Text label for a web form field.\n        default: Default value.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        choices: For a predefined set of options - [[value, Title], ...].\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        default: list[int] | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        choices: list[list[int | str]] | None = None,  # [[value, Title], ...]\n    ) -&gt; None:\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceIntMultField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n            multiple=True,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: list[int] | None = None\n        self.default = default\n        self.choices = choices\n\n        if constants.DEBUG:\n            try:\n                if choices is not None:\n                    if not isinstance(choices, list):\n                        raise AssertionError(\"Parameter `choices` - Not \u0430 `list` type!\")\n                    if len(choices) == 0:\n                        raise AssertionError(\"The `choices` parameter should not contain an empty list!\")\n                if default is not None:\n                    if not isinstance(default, list):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `list` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty list!\")\n                    if choices is not None and not self.has_value():\n                        raise AssertionError(\n                            \"Parameter `default` does not coincide with \" + \"list of permissive values in `choicees`.\",\n                        )\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        value = self.value\n        if value is None:\n            value = self.default\n        if value is not None:\n            choices = self.choices\n            if len(value) == 0 or not bool(choices):\n                return False\n            value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n            for item in value:\n                if item not in value_list:\n                    return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_int_mult_field/#ramifice.fields.choice_int_mult_field.ChoiceIntMultField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_int_mult_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    value = self.value\n    if value is None:\n        value = self.default\n    if value is not None:\n        choices = self.choices\n        if len(value) == 0 or not bool(choices):\n            return False\n        value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n        for item in value:\n            if item not in value_list:\n                return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_text_dyn_field/","title":"ChoiceTextDynField","text":"<p>Field of Model.</p> <p>Type of selective text field with dynamic addition of elements.</p>"},{"location":"pages/fields/choice_text_dyn_field/#ramifice.fields.choice_text_dyn_field.ChoiceTextDynField","title":"<code>ChoiceTextDynField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective text field with dynamic addition of elements. For simulate relationship Many-to-One. Element are (add|delete) via <code>ModelName.unit_manager(unit)</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> Source code in <code>src/ramifice/fields/choice_text_dyn_field.py</code> <pre><code>class ChoiceTextDynField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective text field with dynamic addition of elements.\n    For simulate relationship Many-to-One.\n    Element are (add|delete) via `ModelName.unit_manager(unit)` method.\n\n    Args:\n        label: Text label for a web form field.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceTextDynField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: str | None = None\n        self.choices: list[list[str]] | None = None\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        if is_migrate:\n            return True\n        value = self.value\n        if value is not None:\n            choices = self.choices\n            if not bool(choices):\n                return False\n            if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n                return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_text_dyn_field/#ramifice.fields.choice_text_dyn_field.ChoiceTextDynField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_text_dyn_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    if is_migrate:\n        return True\n    value = self.value\n    if value is not None:\n        choices = self.choices\n        if not bool(choices):\n            return False\n        if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n            return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_text_field/","title":"ChoiceTextField","text":"<p>Field of Model.</p> <p>Type of selective text field with static of elements.</p>"},{"location":"pages/fields/choice_text_field/#ramifice.fields.choice_text_field.ChoiceTextField","title":"<code>ChoiceTextField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective text field with static of elements. With a single choice.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>default</code> <code>str | None</code> <p>Default value.</p> <code>None</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>choices</code> <code>list[list[str]] | None</code> <p>For a predefined set of options - [[value, Title], ...].</p> <code>None</code> Source code in <code>src/ramifice/fields/choice_text_field.py</code> <pre><code>class ChoiceTextField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective text field with static of elements.\n    With a single choice.\n\n    Args:\n        label: Text label for a web form field.\n        default: Default value.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        choices: For a predefined set of options - [[value, Title], ...].\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        default: str | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        choices: list[list[str]] | None = None,  # [[value, Title], ...]\n    ) -&gt; None:\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceTextField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: str | None = None\n        self.default = default\n        self.choices = choices\n\n        if constants.DEBUG:\n            try:\n                if choices is not None:\n                    if not isinstance(choices, list):\n                        raise AssertionError(\"Parameter `choices` - Not \u0430 `list` type!\")\n                    if len(choices) == 0:\n                        raise AssertionError(\"The `choices` parameter should not contain an empty list!\")\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                    if choices is not None and not self.has_value():\n                        raise AssertionError(\n                            \"Parameter `default` does not coincide with \" + \"list of permissive values in `choicees`.\",\n                        )\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        value = self.value\n        if value is None:\n            value = self.default\n        if value is not None:\n            choices = self.choices\n            if not bool(choices):\n                return False\n            if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n                return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_text_field/#ramifice.fields.choice_text_field.ChoiceTextField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_text_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    value = self.value\n    if value is None:\n        value = self.default\n    if value is not None:\n        choices = self.choices\n        if not bool(choices):\n            return False\n        if value not in [item[0] for item in choices]:  # type: ignore[union-attr]\n            return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_text_mult_dyn_field/","title":"ChoiceTextMultDynField","text":"<p>Field of Model.</p> <p>Type of selective text field with dynamic addition of elements.</p>"},{"location":"pages/fields/choice_text_mult_dyn_field/#ramifice.fields.choice_text_mult_dyn_field.ChoiceTextMultDynField","title":"<code>ChoiceTextMultDynField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective text field with dynamic addition of elements. For simulate relationship Many-to-Many.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> Source code in <code>src/ramifice/fields/choice_text_mult_dyn_field.py</code> <pre><code>class ChoiceTextMultDynField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective text field with dynamic addition of elements.\n    For simulate relationship Many-to-Many.\n\n    Args:\n        label: Text label for a web form field.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceTextMultDynField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n            multiple=True,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: list[str] | None = None\n        self.choices: list[list[str]] | None = None\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        if is_migrate:\n            return True\n        value = self.value\n        if value is not None:\n            choices = self.choices\n            if len(value) == 0 or not bool(choices):\n                return False\n            value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n            for item in value:\n                if item not in value_list:\n                    return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_text_mult_dyn_field/#ramifice.fields.choice_text_mult_dyn_field.ChoiceTextMultDynField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_text_mult_dyn_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    if is_migrate:\n        return True\n    value = self.value\n    if value is not None:\n        choices = self.choices\n        if len(value) == 0 or not bool(choices):\n            return False\n        value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n        for item in value:\n            if item not in value_list:\n                return False\n    return True\n</code></pre>"},{"location":"pages/fields/choice_text_mult_field/","title":"ChoiceTextMultField","text":"<p>Field of Model.</p> <p>Type of selective text field with static of elements.</p>"},{"location":"pages/fields/choice_text_mult_field/#ramifice.fields.choice_text_mult_field.ChoiceTextMultField","title":"<code>ChoiceTextMultField</code>","text":"<p>               Bases: <code>Field</code>, <code>ChoiceGroup</code>, <code>JsonMixin</code></p> <p>Field of Model.</p> <p>Type of selective text field with static of elements. With multiple choice.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Text label for a web form field.</p> <code>''</code> <code>default</code> <code>list[str] | None</code> <p>Default value.</p> <code>None</code> <code>hide</code> <code>bool</code> <p>Hide field from user.</p> <code>False</code> <code>disabled</code> <code>bool</code> <p>Blocks access and modification of the element.</p> <code>False</code> <code>ignored</code> <code>bool</code> <p>If true, the value of this field is not saved in the database.</p> <code>False</code> <code>hint</code> <code>str</code> <p>An alternative for the <code>placeholder</code> parameter.</p> <code>''</code> <code>warning</code> <code>list[str] | None</code> <p>Warning information.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Required field.</p> <code>False</code> <code>readonly</code> <code>bool</code> <p>Specifies that the field cannot be modified by the user.</p> <code>False</code> <code>choices</code> <code>list[list[str]] | None</code> <p>For a predefined set of options - [[value, Title], ...].</p> <code>None</code> Source code in <code>src/ramifice/fields/choice_text_mult_field.py</code> <pre><code>class ChoiceTextMultField(Field, ChoiceGroup, JsonMixin):\n    \"\"\"Field of Model.\n\n    Type of selective text field with static of elements.\n    With multiple choice.\n\n    Args:\n        label: Text label for a web form field.\n        default: Default value.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        choices: For a predefined set of options - [[value, Title], ...].\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        default: list[str] | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        choices: list[list[str]] | None = None,  # [[value, Title], ...]\n    ) -&gt; None:\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ChoiceTextMultField\",\n            group=\"choice\",\n        )\n        ChoiceGroup.__init__(\n            self,\n            required=required,\n            readonly=readonly,\n            multiple=True,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: list[str] | None = None\n        self.default = default\n        self.choices = choices\n\n        if constants.DEBUG:\n            try:\n                if choices is not None:\n                    if not isinstance(choices, list):\n                        raise AssertionError(\"Parameter `choices` - Not \u0430 `list` type!\")\n                    if len(choices) == 0:\n                        raise AssertionError(\"The `choices` parameter should not contain an empty list!\")\n                if default is not None:\n                    if not isinstance(default, list):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `list` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty list!\")\n                    if choices is not None and not self.has_value():\n                        raise AssertionError(\n                            \"Parameter `default` does not coincide with \" + \"list of permissive values in `choicees`.\",\n                        )\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n    def has_value(self, is_migrate: bool = False) -&gt; bool:\n        \"\"\"Does the field value match the possible options in choices.\"\"\"\n        value = self.value\n        if value is None:\n            value = self.default\n        if value is not None:\n            choices = self.choices\n            if len(value) == 0 or not bool(choices):\n                return False\n            value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n            for item in value:\n                if item not in value_list:\n                    return False\n        return True\n</code></pre>"},{"location":"pages/fields/choice_text_mult_field/#ramifice.fields.choice_text_mult_field.ChoiceTextMultField.has_value","title":"<code>has_value(is_migrate=False)</code>","text":"<p>Does the field value match the possible options in choices.</p> Source code in <code>src/ramifice/fields/choice_text_mult_field.py</code> <pre><code>def has_value(self, is_migrate: bool = False) -&gt; bool:\n    \"\"\"Does the field value match the possible options in choices.\"\"\"\n    value = self.value\n    if value is None:\n        value = self.default\n    if value is not None:\n        choices = self.choices\n        if len(value) == 0 or not bool(choices):\n            return False\n        value_list = [item[0] for item in choices]  # type: ignore[union-attr]\n        for item in value:\n            if item not in value_list:\n                return False\n    return True\n</code></pre>"},{"location":"pages/fields/color_field/","title":"ColorField","text":"<p>Field of Model for enter color code.</p>"},{"location":"pages/fields/color_field/#ramifice.fields.color_field.ColorField","title":"<code>ColorField</code>","text":"<p>               Bases: <code>Field</code>, <code>TextGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for enter color code.</p> <p>Default value is #000000 (black).</p> <p>Samples:</p>"},{"location":"pages/fields/color_field/#ramifice.fields.color_field.ColorField--ffffff--fff--f2f2f2--f2f2f200--rgb255024-","title":"ffffff | #fff | #f2f2f2 | #f2f2f200 | rgb(255,0,24) |","text":"<p>rgba(255,0,24,0.5) | rgba(#fff,0.5) | hsl(120,100%,50%) | hsla(170,23%,25%,0.2) | 0x00ffff</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection.</p> Source code in <code>src/ramifice/fields/color_field.py</code> <pre><code>class ColorField(Field, TextGroup, JsonMixin):\n    \"\"\"Field of Model for enter color code.\n\n    Default value is #000000 (black).\n\n    Samples:\n    #ffffff | #fff | #f2f2f2 | #f2f2f200 | rgb(255,0,24) |\n    rgba(255,0,24,0.5) | rgba(#fff,0.5) | hsl(120,100%,50%) |\n    hsla(170,23%,25%,0.2) | 0x00ffff\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: str | None = \"#000000\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                    if constants.REGEX[\"color_code\"].match(default) is None:\n                        raise AssertionError(\"Parameter `default` - Not \u0430 color code!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ColorField\",\n            group=\"text\",\n        )\n        TextGroup.__init__(\n            self,\n            input_type=\"text\",\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=unique,\n        )\n        JsonMixin.__init__(self)\n\n        self.default = default\n</code></pre>"},{"location":"pages/fields/date_field/","title":"DateField","text":"<p>Field of Model for enter date.</p>"},{"location":"pages/fields/date_field/#ramifice.fields.date_field.DateField","title":"<code>DateField</code>","text":"<p>               Bases: <code>Field</code>, <code>DateGroup</code></p> <p>Field of Model for enter date.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. max_date: Maximum allowed date. min_date: Minimum allowed date.</p> Source code in <code>src/ramifice/fields/date_field.py</code> <pre><code>class DateField(Field, DateGroup):\n    \"\"\"Field of Model for enter date.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        max_date: Maximum allowed date.\n        min_date: Minimum allowed date.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: datetime | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        max_date: datetime | None = None,\n        min_date: datetime | None = None,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if max_date is not None and not isinstance(max_date, datetime):\n                    raise AssertionError(\"Parameter `max_date` - Not \u0430 `str` type!\")\n                if min_date is not None and not isinstance(min_date, datetime):\n                    raise AssertionError(\"Parameter `min_date` - Not \u0430 `str` type!\")\n                if max_date is not None and min_date is not None and max_date &lt;= min_date:\n                    raise AssertionError(\"The `max_date` parameter should be more than the `min_date`!\")\n                if default is not None:\n                    if not isinstance(default, datetime):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if max_date is not None and default &gt; max_date:\n                        raise AssertionError(\"Parameter `default` is more `max_date`!\")\n                    if min_date is not None and default &lt; min_date:\n                        raise AssertionError(\"Parameter `default` is less `min_date`!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"DateField\",\n            group=\"date\",\n        )\n        DateGroup.__init__(\n            self,\n            input_type=\"date\",\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=False,\n            max_date=max_date,\n            min_date=min_date,\n        )\n\n        self.default = default\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert object instance to a dictionary.\"\"\"\n        json_dict: dict[str, Any] = {}\n        current_locale = translations.CURRENT_LOCALE\n        for name, value in self.__dict__.items():\n            if not callable(value):\n                if name == \"value\" and value is not None:\n                    json_dict[name] = format_date(\n                        date=value.date(),\n                        format=\"short\",\n                        locale=current_locale,\n                    )\n                else:\n                    json_dict[name] = value\n        return json_dict\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object instance to a JSON string.\"\"\"\n        return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n\n    @classmethod\n    def from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        obj = cls()\n        for name, value in json_dict.items():\n            if name == \"value\" and value is not None:\n                obj.__dict__[name] = parse(value)\n            else:\n                obj.__dict__[name] = value\n        return obj\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        json_dict = orjson.loads(json_str)\n        return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/date_field/#ramifice.fields.date_field.DateField.from_dict","title":"<code>from_dict(json_dict)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/date_field.py</code> <pre><code>@classmethod\ndef from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    obj = cls()\n    for name, value in json_dict.items():\n        if name == \"value\" and value is not None:\n            obj.__dict__[name] = parse(value)\n        else:\n            obj.__dict__[name] = value\n    return obj\n</code></pre>"},{"location":"pages/fields/date_field/#ramifice.fields.date_field.DateField.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/date_field.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    json_dict = orjson.loads(json_str)\n    return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/date_field/#ramifice.fields.date_field.DateField.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert object instance to a dictionary.</p> Source code in <code>src/ramifice/fields/date_field.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert object instance to a dictionary.\"\"\"\n    json_dict: dict[str, Any] = {}\n    current_locale = translations.CURRENT_LOCALE\n    for name, value in self.__dict__.items():\n        if not callable(value):\n            if name == \"value\" and value is not None:\n                json_dict[name] = format_date(\n                    date=value.date(),\n                    format=\"short\",\n                    locale=current_locale,\n                )\n            else:\n                json_dict[name] = value\n    return json_dict\n</code></pre>"},{"location":"pages/fields/date_field/#ramifice.fields.date_field.DateField.to_json","title":"<code>to_json()</code>","text":"<p>Convert object instance to a JSON string.</p> Source code in <code>src/ramifice/fields/date_field.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert object instance to a JSON string.\"\"\"\n    return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n</code></pre>"},{"location":"pages/fields/date_time_field/","title":"DateTimeField","text":"<p>Field of Model for enter date and time.</p>"},{"location":"pages/fields/date_time_field/#ramifice.fields.date_time_field.DateTimeField","title":"<code>DateTimeField</code>","text":"<p>               Bases: <code>Field</code>, <code>DateGroup</code></p> <p>Field of Model for enter date and time.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. max_date: Maximum allowed date and time. min_date: Minimum allowed date and time.</p> Source code in <code>src/ramifice/fields/date_time_field.py</code> <pre><code>class DateTimeField(Field, DateGroup):\n    \"\"\"Field of Model for enter date and time.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        max_date: Maximum allowed date and time.\n        min_date: Minimum allowed date and time.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: datetime | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        max_date: datetime | None = None,\n        min_date: datetime | None = None,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if max_date is not None and not isinstance(max_date, datetime):\n                    raise AssertionError(\"Parameter `max_date` - Not \u0430 `str` type!\")\n                if min_date is not None and not isinstance(min_date, datetime):\n                    raise AssertionError(\"Parameter `min_date` - Not \u0430 `str` type!\")\n                if max_date is not None and min_date is not None and max_date &lt;= min_date:\n                    raise AssertionError(\"The `max_date` parameter should be more than the `min_date`!\")\n                if default is not None:\n                    if not isinstance(default, datetime):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if max_date is not None and default &gt; max_date:\n                        raise AssertionError(\"Parameter `default` is more `max_date`!\")\n                    if min_date is not None and default &lt; min_date:\n                        raise AssertionError(\"Parameter `default` is less `min_date`!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"DateTimeField\",\n            group=\"date\",\n        )\n        DateGroup.__init__(\n            self,\n            input_type=\"datetime\",\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=False,\n            max_date=max_date,\n            min_date=min_date,\n        )\n\n        self.default = default\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert object instance to a dictionary.\"\"\"\n        json_dict: dict[str, Any] = {}\n        current_locale = translations.CURRENT_LOCALE\n        for name, value in self.__dict__.items():\n            if not callable(value):\n                if name == \"value\" and value is not None:\n                    json_dict[name] = format_datetime(\n                        datetime=value,\n                        format=\"short\",\n                        locale=current_locale,\n                    )\n                else:\n                    json_dict[name] = value\n        return json_dict\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object instance to a JSON string.\"\"\"\n        return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n\n    @classmethod\n    def from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        obj = cls()\n        for name, value in json_dict.items():\n            if name == \"value\" and value is not None:\n                obj.__dict__[name] = parse(value)\n            else:\n                obj.__dict__[name] = value\n        return obj\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        json_dict = orjson.loads(json_str)\n        return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/date_time_field/#ramifice.fields.date_time_field.DateTimeField.from_dict","title":"<code>from_dict(json_dict)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/date_time_field.py</code> <pre><code>@classmethod\ndef from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    obj = cls()\n    for name, value in json_dict.items():\n        if name == \"value\" and value is not None:\n            obj.__dict__[name] = parse(value)\n        else:\n            obj.__dict__[name] = value\n    return obj\n</code></pre>"},{"location":"pages/fields/date_time_field/#ramifice.fields.date_time_field.DateTimeField.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/date_time_field.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    json_dict = orjson.loads(json_str)\n    return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/date_time_field/#ramifice.fields.date_time_field.DateTimeField.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert object instance to a dictionary.</p> Source code in <code>src/ramifice/fields/date_time_field.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert object instance to a dictionary.\"\"\"\n    json_dict: dict[str, Any] = {}\n    current_locale = translations.CURRENT_LOCALE\n    for name, value in self.__dict__.items():\n        if not callable(value):\n            if name == \"value\" and value is not None:\n                json_dict[name] = format_datetime(\n                    datetime=value,\n                    format=\"short\",\n                    locale=current_locale,\n                )\n            else:\n                json_dict[name] = value\n    return json_dict\n</code></pre>"},{"location":"pages/fields/date_time_field/#ramifice.fields.date_time_field.DateTimeField.to_json","title":"<code>to_json()</code>","text":"<p>Convert object instance to a JSON string.</p> Source code in <code>src/ramifice/fields/date_time_field.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert object instance to a JSON string.\"\"\"\n    return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n</code></pre>"},{"location":"pages/fields/email_field/","title":"EmailField","text":"<p>Field of Model for enter email address.</p>"},{"location":"pages/fields/email_field/#ramifice.fields.email_field.EmailField","title":"<code>EmailField</code>","text":"<p>               Bases: <code>Field</code>, <code>TextGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for enter email address.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection.</p> Source code in <code>src/ramifice/fields/email_field.py</code> <pre><code>class EmailField(Field, TextGroup, JsonMixin):\n    \"\"\"Field of Model for enter email address.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: str | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                    try:\n                        validate_email(default, check_deliverability=True)\n                    except EmailNotValidError:\n                        raise AssertionError(\"Parameter `default` - Invalid Email address!\")  # noqa: B904\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"EmailField\",\n            group=\"text\",\n        )\n        TextGroup.__init__(\n            self,\n            input_type=\"email\",\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=unique,\n        )\n        JsonMixin.__init__(self)\n\n        self.default = default\n</code></pre>"},{"location":"pages/fields/file_field/","title":"FileField","text":"<p>Field of Model for upload file.</p>"},{"location":"pages/fields/file_field/#ramifice.fields.file_field.FileField","title":"<code>FileField</code>","text":"<p>               Bases: <code>Field</code>, <code>FileGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for upload file.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. max_size: The maximum allowed file size in bytes. target_dir: Directory for files inside media directory. accept: Describing which file types to allow. Example: \".pdf,.doc,.docx,application/msword\".</p> Source code in <code>src/ramifice/fields/file_field.py</code> <pre><code>class FileField(Field, FileGroup, JsonMixin):\n    \"\"\"Field of Model for upload file.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        max_size: The maximum allowed file size in bytes.\n        target_dir: Directory for files inside media directory.\n        accept: Describing which file types to allow. Example: \".pdf,.doc,.docx,application/msword\".\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: str | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        # The maximum size of the file in bytes.\n        max_size: int = 2097152,  # 2 MB = 2097152 Bytes (in binary)\n        target_dir: str = \"files\",\n        accept: str = \"\",  # Example: \".pdf,.doc,.docx,application/msword\"\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(max_size, int):\n                    raise AssertionError(\"Parameter `max_size` - Not \u0430 `int` type!\")\n                if not isinstance(target_dir, str):\n                    raise AssertionError(\"Parameter `target_dir` - Not \u0430 `str` type!\")\n                if not isinstance(accept, str):\n                    raise AssertionError(\"Parameter `accept` - Not \u0430 `str` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"FileField\",\n            group=\"file\",\n        )\n        FileGroup.__init__(\n            self,\n            placeholder=placeholder,\n            required=required,\n            max_size=max_size,\n            default=default,\n            target_dir=target_dir,\n            accept=accept,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: dict[str, str | int | bool] | None = None\n\n    async def from_base64(\n        self,\n        base64_str: str | None = None,\n        filename: str | None = None,\n        is_delete: bool = False,\n    ) -&gt; None:\n        \"\"\"Convert base64 to a file,\n        get file information and save in the target directory.\n        \"\"\"  # noqa: D205\n        base64_str = base64_str or None\n        filename = filename or None\n        file_info: dict[str, Any] = {\"save_as_is\": False}\n        file_info[\"is_new_file\"] = True\n        file_info[\"is_delete\"] = is_delete\n\n        if base64_str is not None and filename is not None:\n            # Get file extension.\n            extension = Path(filename).suffix\n            if len(extension) == 0:\n                msg = f\"The file `{filename}` has no extension.\"\n                logger.error(msg)\n                raise FileHasNoExtensionError(msg)\n            # Prepare Base64 content.\n            for item in enumerate(base64_str):\n                if item[1] == \",\":\n                    base64_str = base64_str[item[0] + 1 :]\n                    break\n                if item[0] == 40:\n                    break\n            # Create new (uuid) file name.\n            f_uuid_name = f\"{uuid.uuid4()}{extension}\"\n            # Create the current date for the directory name.\n            date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n            # Create path to target directory.\n            dir_target_path = Path(\n                MEDIA_ROOT,\n                \"uploads\",\n                self.target_dir,\n                date_str,\n            )\n            # Create target directory if it does not exist.\n            if not await dir_target_path.exists():\n                await dir_target_path.mkdir(parents=True)\n            # Create path to target file.\n            f_target_path = f\"{dir_target_path.as_posix()}/{f_uuid_name}\"\n            # Save file in target directory.\n            async with await open_file(f_target_path, mode=\"wb\") as open_f:\n                f_content = b64decode(base64_str)\n                await open_f.write(f_content)\n            # Add paths to target file.\n            file_info[\"path\"] = f_target_path\n            file_info[\"url\"] = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{f_uuid_name}\"\n            # Add original file name.\n            file_info[\"name\"] = filename\n            # Add file extension.\n            file_info[\"extension\"] = extension\n            # Add file size (in bytes).\n            file_info[\"size\"] = await to_thread.run_sync(getsize, f_target_path)\n            # Convert the number of bytes into a human-readable format.\n            # Examples: 200 bytes | 1 KB | 1.5 MB.\n            file_info[\"human_size\"] = to_human_size(file_info[\"size\"])\n        #\n        # to value.\n        self.value = file_info\n\n    async def from_path(\n        self,\n        src_path: str | None = None,\n        is_delete: bool = False,\n    ) -&gt; None:\n        \"\"\"Get file information and copy the file to the target directory.\"\"\"\n        src_path = src_path or None\n        file_info: dict[str, Any] = {\"save_as_is\": False}\n        file_info[\"is_new_file\"] = True\n        file_info[\"is_delete\"] = is_delete\n\n        if src_path is not None:\n            # Get file extension.\n            extension = Path(src_path).suffix\n            if len(extension) == 0:\n                msg = f\"The file `{src_path}` has no extension.\"\n                logger.error(msg)\n                raise FileHasNoExtensionError(msg)\n            # Create new (uuid) file name.\n            f_uuid_name = f\"{uuid.uuid4()}{extension}\"\n            # Create the current date for the directory name.\n            date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n            # Create path to target directory.\n            dir_target_path = Path(\n                MEDIA_ROOT,\n                \"uploads\",\n                self.target_dir,\n                date_str,\n            )\n            # Create target directory if it does not exist.\n            if not await dir_target_path.exists():\n                await dir_target_path.mkdir(parents=True)\n            # Create path to target file.\n            f_target_path = f\"{dir_target_path.as_posix()}/{f_uuid_name}\"\n            # Save file in target directory.\n            await to_thread.run_sync(copyfile, src_path, f_target_path)\n            # Add paths to target file.\n            file_info[\"path\"] = f_target_path\n            file_info[\"url\"] = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{f_uuid_name}\"\n            # Add original file name.\n            file_info[\"name\"] = Path(src_path).name\n            # Add file extension.\n            file_info[\"extension\"] = extension\n            # Add file size (in bytes).\n            file_info[\"size\"] = await to_thread.run_sync(getsize, f_target_path)\n            # Convert the number of bytes into a human-readable format.\n            # Examples: 200 bytes | 1 KB | 1.5 MB.\n            file_info[\"human_size\"] = to_human_size(file_info[\"size\"])\n        #\n        # to value.\n        self.value = file_info\n</code></pre>"},{"location":"pages/fields/file_field/#ramifice.fields.file_field.FileField.from_base64","title":"<code>from_base64(base64_str=None, filename=None, is_delete=False)</code>  <code>async</code>","text":"<p>Convert base64 to a file, get file information and save in the target directory.</p> Source code in <code>src/ramifice/fields/file_field.py</code> <pre><code>async def from_base64(\n    self,\n    base64_str: str | None = None,\n    filename: str | None = None,\n    is_delete: bool = False,\n) -&gt; None:\n    \"\"\"Convert base64 to a file,\n    get file information and save in the target directory.\n    \"\"\"  # noqa: D205\n    base64_str = base64_str or None\n    filename = filename or None\n    file_info: dict[str, Any] = {\"save_as_is\": False}\n    file_info[\"is_new_file\"] = True\n    file_info[\"is_delete\"] = is_delete\n\n    if base64_str is not None and filename is not None:\n        # Get file extension.\n        extension = Path(filename).suffix\n        if len(extension) == 0:\n            msg = f\"The file `{filename}` has no extension.\"\n            logger.error(msg)\n            raise FileHasNoExtensionError(msg)\n        # Prepare Base64 content.\n        for item in enumerate(base64_str):\n            if item[1] == \",\":\n                base64_str = base64_str[item[0] + 1 :]\n                break\n            if item[0] == 40:\n                break\n        # Create new (uuid) file name.\n        f_uuid_name = f\"{uuid.uuid4()}{extension}\"\n        # Create the current date for the directory name.\n        date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n        # Create path to target directory.\n        dir_target_path = Path(\n            MEDIA_ROOT,\n            \"uploads\",\n            self.target_dir,\n            date_str,\n        )\n        # Create target directory if it does not exist.\n        if not await dir_target_path.exists():\n            await dir_target_path.mkdir(parents=True)\n        # Create path to target file.\n        f_target_path = f\"{dir_target_path.as_posix()}/{f_uuid_name}\"\n        # Save file in target directory.\n        async with await open_file(f_target_path, mode=\"wb\") as open_f:\n            f_content = b64decode(base64_str)\n            await open_f.write(f_content)\n        # Add paths to target file.\n        file_info[\"path\"] = f_target_path\n        file_info[\"url\"] = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{f_uuid_name}\"\n        # Add original file name.\n        file_info[\"name\"] = filename\n        # Add file extension.\n        file_info[\"extension\"] = extension\n        # Add file size (in bytes).\n        file_info[\"size\"] = await to_thread.run_sync(getsize, f_target_path)\n        # Convert the number of bytes into a human-readable format.\n        # Examples: 200 bytes | 1 KB | 1.5 MB.\n        file_info[\"human_size\"] = to_human_size(file_info[\"size\"])\n    #\n    # to value.\n    self.value = file_info\n</code></pre>"},{"location":"pages/fields/file_field/#ramifice.fields.file_field.FileField.from_path","title":"<code>from_path(src_path=None, is_delete=False)</code>  <code>async</code>","text":"<p>Get file information and copy the file to the target directory.</p> Source code in <code>src/ramifice/fields/file_field.py</code> <pre><code>async def from_path(\n    self,\n    src_path: str | None = None,\n    is_delete: bool = False,\n) -&gt; None:\n    \"\"\"Get file information and copy the file to the target directory.\"\"\"\n    src_path = src_path or None\n    file_info: dict[str, Any] = {\"save_as_is\": False}\n    file_info[\"is_new_file\"] = True\n    file_info[\"is_delete\"] = is_delete\n\n    if src_path is not None:\n        # Get file extension.\n        extension = Path(src_path).suffix\n        if len(extension) == 0:\n            msg = f\"The file `{src_path}` has no extension.\"\n            logger.error(msg)\n            raise FileHasNoExtensionError(msg)\n        # Create new (uuid) file name.\n        f_uuid_name = f\"{uuid.uuid4()}{extension}\"\n        # Create the current date for the directory name.\n        date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n        # Create path to target directory.\n        dir_target_path = Path(\n            MEDIA_ROOT,\n            \"uploads\",\n            self.target_dir,\n            date_str,\n        )\n        # Create target directory if it does not exist.\n        if not await dir_target_path.exists():\n            await dir_target_path.mkdir(parents=True)\n        # Create path to target file.\n        f_target_path = f\"{dir_target_path.as_posix()}/{f_uuid_name}\"\n        # Save file in target directory.\n        await to_thread.run_sync(copyfile, src_path, f_target_path)\n        # Add paths to target file.\n        file_info[\"path\"] = f_target_path\n        file_info[\"url\"] = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{f_uuid_name}\"\n        # Add original file name.\n        file_info[\"name\"] = Path(src_path).name\n        # Add file extension.\n        file_info[\"extension\"] = extension\n        # Add file size (in bytes).\n        file_info[\"size\"] = await to_thread.run_sync(getsize, f_target_path)\n        # Convert the number of bytes into a human-readable format.\n        # Examples: 200 bytes | 1 KB | 1.5 MB.\n        file_info[\"human_size\"] = to_human_size(file_info[\"size\"])\n    #\n    # to value.\n    self.value = file_info\n</code></pre>"},{"location":"pages/fields/float_field/","title":"FloatField","text":"<p>Field of Model for enter (float) number.</p>"},{"location":"pages/fields/float_field/#ramifice.fields.float_field.FloatField","title":"<code>FloatField</code>","text":"<p>               Bases: <code>Field</code>, <code>NumberGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for enter (float) number.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection. max_number: Maximum allowed number. min_number: Minimum allowed number. step: Increment step for numeric fields. input_type: Field type - <code>number</code> or <code>range</code>.</p> Source code in <code>src/ramifice/fields/float_field.py</code> <pre><code>class FloatField(Field, NumberGroup, JsonMixin):\n    \"\"\"Field of Model for enter (float) number.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n        max_number: Maximum allowed number.\n        min_number: Minimum allowed number.\n        step: Increment step for numeric fields.\n        input_type: Field type - `number` or `range`.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: float | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n        max_number: float | None = None,\n        min_number: float | None = None,\n        step: float = 1.0,\n        input_type: Literal[\"number\", \"range\"] = \"number\",\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if input_type not in [\"number\", \"range\"]:\n                    raise AssertionError(\n                        \"Parameter `input_type` - Invalid input type! \"\n                        + \"The permissible value of `number` or `range`.\",\n                    )\n                if max_number is not None and not isinstance(max_number, float):\n                    raise AssertionError(\"Parameter `max_number` - Not \u0430 number `float` type!\")\n                if min_number is not None and not isinstance(min_number, float):\n                    raise AssertionError(\"Parameter `min_number` - Not \u0430 number `float` type!\")\n                if not isinstance(step, float):\n                    raise AssertionError(\"Parameter `step` - Not \u0430 number `float` type!\")\n                if max_number is not None and min_number is not None and max_number &lt;= min_number:\n                    raise AssertionError(\"The `max_number` parameter should be more than the `min_number`!\")\n                if default is not None:\n                    if not isinstance(default, float):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 number `float` type!\")\n                    if max_number is not None and default &gt; max_number:\n                        raise AssertionError(\"Parameter `default` is more `max_number`!\")\n                    if max_number is not None and default &lt; min_number:\n                        raise AssertionError(\"Parameter `default` is less `min_number`!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"FloatField\",\n            group=\"num\",\n        )\n        NumberGroup.__init__(\n            self,\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=unique,\n        )\n        JsonMixin.__init__(self)\n\n        self.input_type: str = input_type\n        self.value: float | None = None\n        self.default = default\n        self.max_number = max_number\n        self.min_number = min_number\n        self.step = step\n</code></pre>"},{"location":"pages/fields/id_field/","title":"IDField","text":"<p>Field of Model for enter identifier of document.</p>"},{"location":"pages/fields/id_field/#ramifice.fields.id_field.IDField","title":"<code>IDField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field of Model for enter identifier of document.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection.</p> Source code in <code>src/ramifice/fields/id_field.py</code> <pre><code>class IDField(Field):\n    \"\"\"Field of Model for enter identifier of document.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"IDField\",\n            group=\"id\",\n        )\n\n        self.input_type = \"text\"\n        self.value: ObjectId | None = None\n        self.placeholder = placeholder\n        self.required = required\n        self.readonly = readonly\n        self.unique = unique\n        self.alerts: list[str] = []\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert object instance to a dictionary.\"\"\"\n        json_dict: dict[str, Any] = {}\n        for name, data in self.__dict__.items():\n            if not callable(data):\n                if name == \"value\" and data is not None:\n                    json_dict[name] = str(data)\n                else:\n                    json_dict[name] = data\n        return json_dict\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object instance to a JSON string.\"\"\"\n        return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n\n    @classmethod\n    def from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        obj = cls()\n        for name, data in json_dict.items():\n            if name == \"value\" and data is not None:\n                obj.__dict__[name] = ObjectId(data)\n            else:\n                obj.__dict__[name] = data\n        return obj\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        json_dict = orjson.loads(json_str)\n        return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/id_field/#ramifice.fields.id_field.IDField.from_dict","title":"<code>from_dict(json_dict)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/id_field.py</code> <pre><code>@classmethod\ndef from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    obj = cls()\n    for name, data in json_dict.items():\n        if name == \"value\" and data is not None:\n            obj.__dict__[name] = ObjectId(data)\n        else:\n            obj.__dict__[name] = data\n    return obj\n</code></pre>"},{"location":"pages/fields/id_field/#ramifice.fields.id_field.IDField.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/id_field.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    json_dict = orjson.loads(json_str)\n    return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/id_field/#ramifice.fields.id_field.IDField.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert object instance to a dictionary.</p> Source code in <code>src/ramifice/fields/id_field.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert object instance to a dictionary.\"\"\"\n    json_dict: dict[str, Any] = {}\n    for name, data in self.__dict__.items():\n        if not callable(data):\n            if name == \"value\" and data is not None:\n                json_dict[name] = str(data)\n            else:\n                json_dict[name] = data\n    return json_dict\n</code></pre>"},{"location":"pages/fields/id_field/#ramifice.fields.id_field.IDField.to_json","title":"<code>to_json()</code>","text":"<p>Convert object instance to a JSON string.</p> Source code in <code>src/ramifice/fields/id_field.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert object instance to a JSON string.\"\"\"\n    return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n</code></pre>"},{"location":"pages/fields/image_field/","title":"ImageField","text":"<p>Field of Model for upload image.</p>"},{"location":"pages/fields/image_field/#ramifice.fields.image_field.ImageField","title":"<code>ImageField</code>","text":"<p>               Bases: <code>Field</code>, <code>FileGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for upload image.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. max_size: The maximum allowed file size in bytes. target_dir: Directory for files inside media directory. accept: Describing which file types to allow. Example: \"image/png,image/jpeg,image/webp\". thumbnails: Sizes of thumbnails - Example: {\"lg\": 1200, \"md\": 600, \"sm\": 300, \"xs\": 150 }.</p> Source code in <code>src/ramifice/fields/image_field.py</code> <pre><code>class ImageField(Field, FileGroup, JsonMixin):\n    \"\"\"Field of Model for upload image.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        max_size: The maximum allowed file size in bytes.\n        target_dir: Directory for files inside media directory.\n        accept: Describing which file types to allow. Example: \"image/png,image/jpeg,image/webp\".\n        thumbnails: Sizes of thumbnails - Example: {\"lg\": 1200, \"md\": 600, \"sm\": 300, \"xs\": 150 }.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: str | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        # The maximum size of the original image in bytes.\n        max_size: int = 2097152,  # 2 MB = 2097152 Bytes (in binary)\n        target_dir: str = \"images\",\n        accept: str = \"image/png,image/jpeg,image/webp\",\n        # Available 4 sizes from lg to xs or None.\n        thumbnails: dict[str, int] | None = None,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                if thumbnails is not None:\n                    if not isinstance(thumbnails, dict):\n                        raise AssertionError(\"Parameter `thumbnails` - Not \u0430 `dict` type!\")\n                    if len(thumbnails) == 0:\n                        raise AssertionError(\"The `thumbnails` parameter should not contain an empty dictionary!\")\n                    size_name_list = [\"lg\", \"md\", \"sm\", \"xs\"]\n                    curr_size_thumb: int = 0\n                    for size_name in thumbnails:\n                        if size_name not in size_name_list:\n                            raise AssertionError(\n                                f\"The `thumbnails` parameter contains an unacceptable size name `{size_name}`!\\n\"\n                                + \" Allowed names: lg, md, sm, xs.\\n\"\n                                + \" Use all sizes is not necessary.\",\n                            )\n                        max_size_thumb: int | None = thumbnails.get(size_name)\n                        if max_size_thumb is not None:\n                            if curr_size_thumb &gt; 0 and max_size_thumb &gt;= curr_size_thumb:\n                                raise AssertionError(\n                                    \"The `thumbnails` parameter -&gt; \"\n                                    + f\"The `{size_name}` key should be less than a previous size!\"\n                                    + 'Example: {\"lg\": 1200, \"md\": 600, \"sm\": 300, \"xs\": 150 }',\n                                )\n                            curr_size_thumb = max_size_thumb\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(max_size, int):\n                    raise AssertionError(\"Parameter `max_size` - Not \u0430 `int` type!\")\n                if not isinstance(target_dir, str):\n                    raise AssertionError(\"Parameter `target_dir` - Not \u0430 `str` type!\")\n                if not isinstance(accept, str):\n                    raise AssertionError(\"Parameter `accept` - Not \u0430 `str` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"ImageField\",\n            group=\"img\",\n        )\n        FileGroup.__init__(\n            self,\n            placeholder=placeholder,\n            required=required,\n            max_size=max_size,\n            default=default,\n            target_dir=target_dir,\n            accept=accept,\n        )\n        JsonMixin.__init__(self)\n\n        self.value: dict[str, str | int | bool] | None = None\n        # Available 4 sizes from lg to xs or None.\n        self.thumbnails = thumbnails\n\n    async def from_base64(\n        self,\n        base64_str: str | None = None,\n        filename: str | None = None,\n        is_delete: bool = False,\n    ) -&gt; None:\n        \"\"\"Convert base64 to a image,\n        get image information and save in the target directory.\n        \"\"\"  # noqa: D205\n        base64_str = base64_str or None\n        filename = filename or None\n        img_info: dict[str, Any] = {\"save_as_is\": False}\n        img_info[\"is_new_img\"] = True\n        img_info[\"is_delete\"] = is_delete\n\n        if base64_str is not None and filename is not None:\n            # Get file extension.\n            extension = Path(filename).suffix\n            if len(extension) == 0:\n                msg = f\"The image `{filename}` has no extension.\"\n                logger.error(msg)\n                raise FileHasNoExtensionError(msg)\n            # Prepare Base64 content.\n            for item in enumerate(base64_str):\n                if item[1] == \",\":\n                    base64_str = base64_str[item[0] + 1 :]\n                    break\n                if item[0] == 40:\n                    break\n            # Create the current date for the directory name.\n            date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n            # Directory name for the original image and its thumbnails.\n            general_dir = str(uuid.uuid4())\n            # Create path to target directory with images.\n            imgs_dir_path = Path(\n                MEDIA_ROOT,\n                \"uploads\",\n                self.target_dir,\n                date_str,\n                general_dir,\n            )\n            # Create target directory if it does not exist.\n            if not await imgs_dir_path.exists():\n                await imgs_dir_path.mkdir(parents=True)\n            # Create url path to target directory with images.\n            imgs_dir_url = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{general_dir}\"\n            # Create a new name for the original image.\n            new_original_name = f\"original{extension}\"\n            # Create path to main image.\n            main_img_path = Path(imgs_dir_path, new_original_name)\n            # Save main image in target directory.\n            async with await open_file(main_img_path, mode=\"wb\") as open_f:\n                f_content = b64decode(base64_str)\n                await open_f.write(f_content)\n            # Add paths for main image.\n            img_info[\"path\"] = main_img_path.as_posix()\n            img_info[\"url\"] = f\"{imgs_dir_url}/{new_original_name}\"\n            # Add original image name.\n            img_info[\"name\"] = filename\n            # Add image extension.\n            img_info[\"extension\"] = extension\n            # Transform extension to the upper register and delete the point.\n            ext_upper = extension[1:].upper()\n            if ext_upper == \"JPG\":\n                ext_upper = \"JPEG\"\n            img_info[\"ext_upper\"] = ext_upper\n            # Add path to target directory with images.\n            img_info[\"imgs_dir_path\"] = imgs_dir_path.as_posix()\n            # Add url path to target directory with images.\n            img_info[\"imgs_dir_url\"] = imgs_dir_url\n            # Add size of main image (in bytes).\n            img_info[\"size\"] = await to_thread.run_sync(getsize, main_img_path)\n            # Convert the number of bytes into a human-readable format.\n            # Examples: 200 bytes | 1 KB | 1.5 MB.\n            img_info[\"human_size\"] = to_human_size(img_info[\"size\"])\n        #\n        # to value.\n        self.value = img_info\n\n    async def from_path(\n        self,\n        src_path: str | None = None,\n        is_delete: bool = False,\n    ) -&gt; None:\n        \"\"\"Get image information and copy the image to the target directory.\"\"\"\n        src_path = src_path or None\n        img_info: dict[str, Any] = {\"save_as_is\": False}\n        img_info[\"is_new_img\"] = True\n        img_info[\"is_delete\"] = is_delete\n\n        if src_path is not None:\n            # Get file extension.\n            extension = Path(src_path).suffix\n            if len(extension) == 0:\n                msg = f\"The image `{src_path}` has no extension.\"\n                logger.error(msg)\n                raise FileHasNoExtensionError(msg)\n            # Create the current date for the directory name.\n            date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n            # Directory name for the original image and its thumbnails.\n            general_dir = str(uuid.uuid4())\n            # Create path to target directory with images.\n            imgs_dir_path = Path(\n                MEDIA_ROOT,\n                \"uploads\",\n                self.target_dir,\n                date_str,\n                general_dir,\n            )\n            # Create url path to target directory with images.\n            imgs_dir_url = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{general_dir}\"\n            # Create target directory if it does not exist.\n            if not await imgs_dir_path.exists():\n                await imgs_dir_path.mkdir(parents=True)\n            # Create a new name for the original image.\n            new_original_name = f\"original{extension}\"\n            # Create path to main image.\n            main_img_path = f\"{imgs_dir_path.as_posix()}/{new_original_name}\"\n            # Save main image in target directory.\n            await to_thread.run_sync(copyfile, src_path, main_img_path)\n            # Add paths for main image.\n            img_info[\"path\"] = main_img_path\n            img_info[\"url\"] = f\"{imgs_dir_url}/{new_original_name}\"\n            # Add original image name.\n            img_info[\"name\"] = Path(src_path).name\n            # Add image extension.\n            img_info[\"extension\"] = extension\n            # Transform extension to the upper register and delete the point.\n            ext_upper = extension[1:].upper()\n            if ext_upper == \"JPG\":\n                ext_upper = \"JPEG\"\n            img_info[\"ext_upper\"] = ext_upper\n            # Add path to target directory with images.\n            img_info[\"imgs_dir_path\"] = imgs_dir_path.as_posix()\n            # Add url path to target directory with images.\n            img_info[\"imgs_dir_url\"] = imgs_dir_url\n            # Add size of main image (in bytes).\n            img_info[\"size\"] = await to_thread.run_sync(getsize, main_img_path)\n            # Convert the number of bytes into a human-readable format.\n            # Examples: 200 bytes | 1 KB | 1.5 MB.\n            img_info[\"human_size\"] = to_human_size(img_info[\"size\"])\n        #\n        # to value.\n        self.value = img_info\n</code></pre>"},{"location":"pages/fields/image_field/#ramifice.fields.image_field.ImageField.from_base64","title":"<code>from_base64(base64_str=None, filename=None, is_delete=False)</code>  <code>async</code>","text":"<p>Convert base64 to a image, get image information and save in the target directory.</p> Source code in <code>src/ramifice/fields/image_field.py</code> <pre><code>async def from_base64(\n    self,\n    base64_str: str | None = None,\n    filename: str | None = None,\n    is_delete: bool = False,\n) -&gt; None:\n    \"\"\"Convert base64 to a image,\n    get image information and save in the target directory.\n    \"\"\"  # noqa: D205\n    base64_str = base64_str or None\n    filename = filename or None\n    img_info: dict[str, Any] = {\"save_as_is\": False}\n    img_info[\"is_new_img\"] = True\n    img_info[\"is_delete\"] = is_delete\n\n    if base64_str is not None and filename is not None:\n        # Get file extension.\n        extension = Path(filename).suffix\n        if len(extension) == 0:\n            msg = f\"The image `{filename}` has no extension.\"\n            logger.error(msg)\n            raise FileHasNoExtensionError(msg)\n        # Prepare Base64 content.\n        for item in enumerate(base64_str):\n            if item[1] == \",\":\n                base64_str = base64_str[item[0] + 1 :]\n                break\n            if item[0] == 40:\n                break\n        # Create the current date for the directory name.\n        date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n        # Directory name for the original image and its thumbnails.\n        general_dir = str(uuid.uuid4())\n        # Create path to target directory with images.\n        imgs_dir_path = Path(\n            MEDIA_ROOT,\n            \"uploads\",\n            self.target_dir,\n            date_str,\n            general_dir,\n        )\n        # Create target directory if it does not exist.\n        if not await imgs_dir_path.exists():\n            await imgs_dir_path.mkdir(parents=True)\n        # Create url path to target directory with images.\n        imgs_dir_url = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{general_dir}\"\n        # Create a new name for the original image.\n        new_original_name = f\"original{extension}\"\n        # Create path to main image.\n        main_img_path = Path(imgs_dir_path, new_original_name)\n        # Save main image in target directory.\n        async with await open_file(main_img_path, mode=\"wb\") as open_f:\n            f_content = b64decode(base64_str)\n            await open_f.write(f_content)\n        # Add paths for main image.\n        img_info[\"path\"] = main_img_path.as_posix()\n        img_info[\"url\"] = f\"{imgs_dir_url}/{new_original_name}\"\n        # Add original image name.\n        img_info[\"name\"] = filename\n        # Add image extension.\n        img_info[\"extension\"] = extension\n        # Transform extension to the upper register and delete the point.\n        ext_upper = extension[1:].upper()\n        if ext_upper == \"JPG\":\n            ext_upper = \"JPEG\"\n        img_info[\"ext_upper\"] = ext_upper\n        # Add path to target directory with images.\n        img_info[\"imgs_dir_path\"] = imgs_dir_path.as_posix()\n        # Add url path to target directory with images.\n        img_info[\"imgs_dir_url\"] = imgs_dir_url\n        # Add size of main image (in bytes).\n        img_info[\"size\"] = await to_thread.run_sync(getsize, main_img_path)\n        # Convert the number of bytes into a human-readable format.\n        # Examples: 200 bytes | 1 KB | 1.5 MB.\n        img_info[\"human_size\"] = to_human_size(img_info[\"size\"])\n    #\n    # to value.\n    self.value = img_info\n</code></pre>"},{"location":"pages/fields/image_field/#ramifice.fields.image_field.ImageField.from_path","title":"<code>from_path(src_path=None, is_delete=False)</code>  <code>async</code>","text":"<p>Get image information and copy the image to the target directory.</p> Source code in <code>src/ramifice/fields/image_field.py</code> <pre><code>async def from_path(\n    self,\n    src_path: str | None = None,\n    is_delete: bool = False,\n) -&gt; None:\n    \"\"\"Get image information and copy the image to the target directory.\"\"\"\n    src_path = src_path or None\n    img_info: dict[str, Any] = {\"save_as_is\": False}\n    img_info[\"is_new_img\"] = True\n    img_info[\"is_delete\"] = is_delete\n\n    if src_path is not None:\n        # Get file extension.\n        extension = Path(src_path).suffix\n        if len(extension) == 0:\n            msg = f\"The image `{src_path}` has no extension.\"\n            logger.error(msg)\n            raise FileHasNoExtensionError(msg)\n        # Create the current date for the directory name.\n        date_str: str = str(datetime.now(UTC_TIMEZONE).date())\n        # Directory name for the original image and its thumbnails.\n        general_dir = str(uuid.uuid4())\n        # Create path to target directory with images.\n        imgs_dir_path = Path(\n            MEDIA_ROOT,\n            \"uploads\",\n            self.target_dir,\n            date_str,\n            general_dir,\n        )\n        # Create url path to target directory with images.\n        imgs_dir_url = f\"{MEDIA_URL}/uploads/{self.target_dir}/{date_str}/{general_dir}\"\n        # Create target directory if it does not exist.\n        if not await imgs_dir_path.exists():\n            await imgs_dir_path.mkdir(parents=True)\n        # Create a new name for the original image.\n        new_original_name = f\"original{extension}\"\n        # Create path to main image.\n        main_img_path = f\"{imgs_dir_path.as_posix()}/{new_original_name}\"\n        # Save main image in target directory.\n        await to_thread.run_sync(copyfile, src_path, main_img_path)\n        # Add paths for main image.\n        img_info[\"path\"] = main_img_path\n        img_info[\"url\"] = f\"{imgs_dir_url}/{new_original_name}\"\n        # Add original image name.\n        img_info[\"name\"] = Path(src_path).name\n        # Add image extension.\n        img_info[\"extension\"] = extension\n        # Transform extension to the upper register and delete the point.\n        ext_upper = extension[1:].upper()\n        if ext_upper == \"JPG\":\n            ext_upper = \"JPEG\"\n        img_info[\"ext_upper\"] = ext_upper\n        # Add path to target directory with images.\n        img_info[\"imgs_dir_path\"] = imgs_dir_path.as_posix()\n        # Add url path to target directory with images.\n        img_info[\"imgs_dir_url\"] = imgs_dir_url\n        # Add size of main image (in bytes).\n        img_info[\"size\"] = await to_thread.run_sync(getsize, main_img_path)\n        # Convert the number of bytes into a human-readable format.\n        # Examples: 200 bytes | 1 KB | 1.5 MB.\n        img_info[\"human_size\"] = to_human_size(img_info[\"size\"])\n    #\n    # to value.\n    self.value = img_info\n</code></pre>"},{"location":"pages/fields/integer_field/","title":"IntegerField","text":"<p>Field of Model for enter (int) number.</p>"},{"location":"pages/fields/integer_field/#ramifice.fields.integer_field.IntegerField","title":"<code>IntegerField</code>","text":"<p>               Bases: <code>Field</code>, <code>NumberGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for enter (int) number.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection. max_number: Maximum allowed number. min_number: Minimum allowed number. step: Increment step for numeric fields. input_type: Field type - <code>number</code> or <code>range</code>.</p> Source code in <code>src/ramifice/fields/integer_field.py</code> <pre><code>class IntegerField(Field, NumberGroup, JsonMixin):\n    \"\"\"Field of Model for enter (int) number.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n        max_number: Maximum allowed number.\n        min_number: Minimum allowed number.\n        step: Increment step for numeric fields.\n        input_type: Field type - `number` or `range`.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: int | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n        max_number: int | None = None,\n        min_number: int | None = None,\n        step: int = 1,\n        input_type: Literal[\"number\", \"range\"] = \"number\",\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if input_type not in [\"number\", \"range\"]:\n                    raise AssertionError(\n                        \"Parameter `input_type` - Invalid input type! \"\n                        + \"The permissible value of `number` or `range`.\",\n                    )\n                if max_number is not None and not isinstance(max_number, int):\n                    raise AssertionError(\"Parameter `max_number` - Not \u0430 number `int` type!\")\n                if min_number is not None and not isinstance(min_number, int):\n                    raise AssertionError(\"Parameter `min_number` - Not \u0430 number `int` type!\")\n                if not isinstance(step, int):\n                    raise AssertionError(\"Parameter `step` - Not \u0430 number `int` type!\")\n                if max_number is not None and min_number is not None and max_number &lt;= min_number:\n                    raise AssertionError(\"The `max_number` parameter should be more than the `min_number`!\")\n                if default is not None:\n                    if not isinstance(default, int):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 number `int` type!\")\n                    if max_number is not None and default &gt; max_number:\n                        raise AssertionError(\"Parameter `default` is more `max_number`!\")\n                    if max_number is not None and default &lt; min_number:\n                        raise AssertionError(\"Parameter `default` is less `min_number`!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"IntegerField\",\n            group=\"num\",\n        )\n        NumberGroup.__init__(\n            self,\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=unique,\n        )\n        JsonMixin.__init__(self)\n\n        self.input_type: str = input_type\n        self.value: int | None = None\n        self.default = default\n        self.max_number = max_number\n        self.min_number = min_number\n        self.step = step\n</code></pre>"},{"location":"pages/fields/ip_field/","title":"IPField","text":"<p>Field of Model for enter IP address.</p>"},{"location":"pages/fields/ip_field/#ramifice.fields.ip_field.IPField","title":"<code>IPField</code>","text":"<p>               Bases: <code>Field</code>, <code>TextGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for enter IP address.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection.</p> Source code in <code>src/ramifice/fields/ip_field.py</code> <pre><code>class IPField(Field, TextGroup, JsonMixin):\n    \"\"\"Field of Model for enter IP address.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: str | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                    try:\n                        ipaddress.ip_address(default)\n                    except ValueError:\n                        raise AssertionError(\"Parameter `default` - Invalid IP address!\")  # noqa: B904\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"IPField\",\n            group=\"text\",\n        )\n        TextGroup.__init__(\n            self,\n            input_type=\"text\",\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=unique,\n        )\n        JsonMixin.__init__(self)\n\n        self.default = default\n</code></pre>"},{"location":"pages/fields/password_field/","title":"PasswordField","text":"<p>Field of Model for enter password.</p>"},{"location":"pages/fields/password_field/#ramifice.fields.password_field.PasswordField","title":"<code>PasswordField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field of Model for enter password.</p> Attention <ul> <li><code>Regular expression:</code> ^[-._!\"`'#%&amp;,:;&lt;&gt;=@{}~$()*+/\\?[]^|a-zA-Z0-9]{8,256}$</li> <li><code>Valid characters:</code> a-z A-Z 0-9 - . _ ! \" ` ' # % &amp; , : ; &lt; &gt; = @ { } ~ $ ( ) * + / \\ ? [ ] ^ |</li> <li><code>Number of characters:</code> from 8 to 256.</li> </ul> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. hide: Hide field from user. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field.</p> Source code in <code>src/ramifice/fields/password_field.py</code> <pre><code>class PasswordField(Field):\n    r\"\"\"Field of Model for enter password.\n\n    Attention:\n        - `Regular expression:` ^[-._!\"`'#%&amp;,:;&lt;&gt;=@{}~$()*+/\\\\?[]^|a-zA-Z0-9]{8,256}$\n        - `Valid characters:` a-z A-Z 0-9 - . _ ! \" ` ' # % &amp; , : ; &lt; &gt; = @ { } ~ $ ( ) * + / \\\\ ? [ ] ^ |\n        - `Number of characters:` from 8 to 256.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        hide: Hide field from user.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        hide: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=False,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"PasswordField\",\n            group=\"pass\",\n        )\n\n        self.input_type = \"password\"\n        self.value: str | None = None\n        self.placeholder = placeholder\n        self.required = required\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert object instance to a dictionary.\"\"\"\n        json_dict: dict[str, Any] = {}\n        for name, data in self.__dict__.items():\n            if not callable(data):\n                json_dict[name] = data if name != \"value\" else None\n        return json_dict\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object instance to a JSON string.\"\"\"\n        return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n\n    @classmethod\n    def from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        obj = cls()\n        for name, data in json_dict.items():\n            obj.__dict__[name] = data\n        return obj\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        json_dict = orjson.loads(json_str)\n        return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/password_field/#ramifice.fields.password_field.PasswordField.from_dict","title":"<code>from_dict(json_dict)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/password_field.py</code> <pre><code>@classmethod\ndef from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    obj = cls()\n    for name, data in json_dict.items():\n        obj.__dict__[name] = data\n    return obj\n</code></pre>"},{"location":"pages/fields/password_field/#ramifice.fields.password_field.PasswordField.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/fields/password_field.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    json_dict = orjson.loads(json_str)\n    return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/fields/password_field/#ramifice.fields.password_field.PasswordField.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert object instance to a dictionary.</p> Source code in <code>src/ramifice/fields/password_field.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert object instance to a dictionary.\"\"\"\n    json_dict: dict[str, Any] = {}\n    for name, data in self.__dict__.items():\n        if not callable(data):\n            json_dict[name] = data if name != \"value\" else None\n    return json_dict\n</code></pre>"},{"location":"pages/fields/password_field/#ramifice.fields.password_field.PasswordField.to_json","title":"<code>to_json()</code>","text":"<p>Convert object instance to a JSON string.</p> Source code in <code>src/ramifice/fields/password_field.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert object instance to a JSON string.\"\"\"\n    return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n</code></pre>"},{"location":"pages/fields/phone_field/","title":"PhoneField","text":"<p>Field of Model for enter phone number.</p>"},{"location":"pages/fields/phone_field/#ramifice.fields.phone_field.PhoneField","title":"<code>PhoneField</code>","text":"<p>               Bases: <code>Field</code>, <code>TextGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for enter phone number.</p> Attention <p>By default is used validator <code>phonenumbers.is_valid_number()</code>.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection.</p> Source code in <code>src/ramifice/fields/phone_field.py</code> <pre><code>class PhoneField(Field, TextGroup, JsonMixin):\n    \"\"\"Field of Model for enter phone number.\n\n    Attention:\n        By default is used validator `phonenumbers.is_valid_number()`.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: str | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                    try:\n                        phone_default = phonenumbers.parse(default)\n                        if not phonenumbers.is_valid_number(phone_default):\n                            raise AssertionError()\n                    except phonenumbers.phonenumberutil.NumberParseException:\n                        raise AssertionError(\"Parameter `default` - Invalid Phone number!\")  # noqa: B904\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"PhoneField\",\n            group=\"text\",\n        )\n        TextGroup.__init__(\n            self,\n            input_type=\"tel\",\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=unique,\n        )\n        JsonMixin.__init__(self)\n\n        self.default = default\n</code></pre>"},{"location":"pages/fields/slug_field/","title":"SlugField","text":"<p>Field of Model for automatic generation of string <code>slug</code>.</p>"},{"location":"pages/fields/slug_field/#ramifice.fields.slug_field.SlugField","title":"<code>SlugField</code>","text":"<p>               Bases: <code>Field</code>, <code>TextGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for automatic generation of string <code>slug</code>.</p> <p>Convenient to use for Url addresses.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. readonly: Specifies that the field cannot be modified by the user. slug_sources: List of sources fields.</p> Source code in <code>src/ramifice/fields/slug_field.py</code> <pre><code>class SlugField(Field, TextGroup, JsonMixin):\n    \"\"\"Field of Model for automatic generation of string `slug`.\n\n    Convenient to use for Url addresses.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        readonly: Specifies that the field cannot be modified by the user.\n        slug_sources: List of sources fields.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        readonly: bool = False,\n        slug_sources: list[str] = [\"_id\"],  # noqa: B006\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(slug_sources, list):\n                    raise AssertionError(\"Parameter `slug_sources` - Not \u0430 `list` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"SlugField\",\n            group=\"slug\",\n        )\n        TextGroup.__init__(\n            self,\n            input_type=\"text\",\n            placeholder=placeholder,\n            required=False,\n            readonly=readonly,\n            unique=True,\n        )\n        JsonMixin.__init__(self)\n\n        self.slug_sources = slug_sources\n</code></pre>"},{"location":"pages/fields/text_field/","title":"TextField","text":"<p>Field of Model for enter text.</p>"},{"location":"pages/fields/text_field/#ramifice.fields.text_field.TextField","title":"<code>TextField</code>","text":"<p>               Bases: <code>Field</code>, <code>JsonMixin</code></p> <p>Field of Model for enter text.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. textarea: Is it necessary to use the Textarea widget. use_editor: Is it necessary to use the widget of the text editor. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection. maxlength: The maximum line length. multi_language: Is it need support for several languages.</p> Source code in <code>src/ramifice/fields/text_field.py</code> <pre><code>class TextField(Field, JsonMixin):\n    \"\"\"Field of Model for enter text.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        textarea: Is it necessary to use the Textarea widget.\n        use_editor: Is it necessary to use the widget of the text editor.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n        maxlength: The maximum line length.\n        multi_language: Is it need support for several languages.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        textarea: bool = False,\n        use_editor: bool = False,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n        maxlength: int = 256,\n        # Support for several language.\n        multi_language: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if not isinstance(maxlength, int):\n                    raise AssertionError(\"Parameter `maxlength` - Not \u0430 `int` type!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n                if not isinstance(textarea, bool):\n                    raise AssertionError(\"Parameter `textarea` - Not \u0430 `bool` type!\")\n                if not isinstance(use_editor, bool):\n                    raise AssertionError(\"Parameter `use_editor` - Not \u0430 `bool` type!\")\n                if not isinstance(maxlength, int):\n                    raise AssertionError(\"Parameter `maxlength` - Not \u0430 `int` type!\")\n                if not isinstance(multi_language, bool):\n                    raise AssertionError(\"Parameter `multi_language` - Not \u0430 `int` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"TextField\",\n            group=\"text\",\n        )\n        JsonMixin.__init__(self)\n\n        self.value: str | dict[str, str] | None = None\n        self.input_type = \"text\"\n        self.placeholder = placeholder\n        self.required = required\n        self.readonly = readonly\n        self.unique = unique\n        self.textarea = textarea\n        self.use_editor = use_editor\n        self.maxlength = maxlength\n        # Support for several language.\n        self.multi_language = multi_language\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return length of field `value`.\"\"\"\n        value = self.value\n        if isinstance(value, str):\n            return len(value)\n        if isinstance(value, dict):\n            count = 0\n            for text in value.values():\n                tmp = len(text)\n                if tmp &gt; count:\n                    count = tmp\n            return count\n        return 0\n</code></pre>"},{"location":"pages/fields/text_field/#ramifice.fields.text_field.TextField.__len__","title":"<code>__len__()</code>","text":"<p>Return length of field <code>value</code>.</p> Source code in <code>src/ramifice/fields/text_field.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return length of field `value`.\"\"\"\n    value = self.value\n    if isinstance(value, str):\n        return len(value)\n    if isinstance(value, dict):\n        count = 0\n        for text in value.values():\n            tmp = len(text)\n            if tmp &gt; count:\n                count = tmp\n        return count\n    return 0\n</code></pre>"},{"location":"pages/fields/url_field/","title":"URLField","text":"<p>Field of Model for enter URL address.</p>"},{"location":"pages/fields/url_field/#ramifice.fields.url_field.URLField","title":"<code>URLField</code>","text":"<p>               Bases: <code>Field</code>, <code>TextGroup</code>, <code>JsonMixin</code></p> <p>Field of Model for enter URL address.</p> Agrs <p>label: Text label for a web form field. placeholder: Displays prompt text. default: Value by default. hide: Hide field from user. disabled: Blocks access and modification of the element. ignored: If true, the value of this field is not saved in the database. hint: An alternative for the <code>placeholder</code> parameter. warning: Warning information. required: Required field. readonly: Specifies that the field cannot be modified by the user. unique: The unique value of a field in a collection.</p> Source code in <code>src/ramifice/fields/url_field.py</code> <pre><code>class URLField(Field, TextGroup, JsonMixin):\n    \"\"\"Field of Model for enter URL address.\n\n    Agrs:\n        label: Text label for a web form field.\n        placeholder: Displays prompt text.\n        default: Value by default.\n        hide: Hide field from user.\n        disabled: Blocks access and modification of the element.\n        ignored: If true, the value of this field is not saved in the database.\n        hint: An alternative for the `placeholder` parameter.\n        warning: Warning information.\n        required: Required field.\n        readonly: Specifies that the field cannot be modified by the user.\n        unique: The unique value of a field in a collection.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        label: str = \"\",\n        placeholder: str = \"\",\n        default: str | None = None,\n        hide: bool = False,\n        disabled: bool = False,\n        ignored: bool = False,\n        hint: str = \"\",\n        warning: list[str] | None = None,\n        required: bool = False,\n        readonly: bool = False,\n        unique: bool = False,\n    ) -&gt; None:\n        if constants.DEBUG:\n            try:\n                if default is not None:\n                    if not isinstance(default, str):\n                        raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                    if len(default) == 0:\n                        raise AssertionError(\"The `default` parameter should not contain an empty string!\")\n                    result = urlparse(default)\n                    if not result.scheme or not result.netloc:\n                        raise AssertionError(\"Parameter `default` - Invalid URL address!\")\n                if not isinstance(label, str):\n                    raise AssertionError(\"Parameter `default` - Not \u0430 `str` type!\")\n                if not isinstance(disabled, bool):\n                    raise AssertionError(\"Parameter `disabled` - Not \u0430 `bool` type!\")\n                if not isinstance(hide, bool):\n                    raise AssertionError(\"Parameter `hide` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(ignored, bool):\n                    raise AssertionError(\"Parameter `ignored` - Not \u0430 `bool` type!\")\n                if not isinstance(hint, str):\n                    raise AssertionError(\"Parameter `hint` - Not \u0430 `str` type!\")\n                if warning is not None and not isinstance(warning, list):\n                    raise AssertionError(\"Parameter `warning` - Not \u0430 `list` type!\")\n                if not isinstance(placeholder, str):\n                    raise AssertionError(\"Parameter `placeholder` - Not \u0430 `str` type!\")\n                if not isinstance(required, bool):\n                    raise AssertionError(\"Parameter `required` - Not \u0430 `bool` type!\")\n                if not isinstance(readonly, bool):\n                    raise AssertionError(\"Parameter `readonly` - Not \u0430 `bool` type!\")\n                if not isinstance(unique, bool):\n                    raise AssertionError(\"Parameter `unique` - Not \u0430 `bool` type!\")\n            except AssertionError as err:\n                logger.critical(str(err))\n                raise err\n\n        Field.__init__(\n            self,\n            label=label,\n            disabled=disabled,\n            hide=hide,\n            ignored=ignored,\n            hint=hint,\n            warning=warning,\n            field_type=\"URLField\",\n            group=\"text\",\n        )\n        TextGroup.__init__(\n            self,\n            input_type=\"url\",\n            placeholder=placeholder,\n            required=required,\n            readonly=readonly,\n            unique=unique,\n        )\n        JsonMixin.__init__(self)\n\n        self.default = default\n</code></pre>"},{"location":"pages/installation/","title":"Installation","text":"<ul> <li> <p>Install MongoDB (if not installed): </p> </li> <li> <p>Run:</p> </li> </ul> <pre><code># Fedora:\nsudo dnf install gettext\ngettext --version\n# Ubuntu:\nsudo apt install gettext\ngettext --version\n# Windows:\nhttps://mlocati.github.io/articles/gettext-iconv-windows.html\ngettext --version\n\ncd project_name\nuv add ramifice\n</code></pre> <ul> <li>Add <code>config</code> and <code>public</code> directories in root of your project: Download config directory Download public directory</li> </ul>"},{"location":"pages/localization/","title":"Localization","text":""},{"location":"pages/localization/#how-to-create-custom-translations-","title":"How to create custom translations ?","text":"<pre><code>from ramifice import translations\n\ntranslations.add_languages(\n    default_locale=\"en\",  # For Ramifice by default = \"en\"\n    languages=frozenset((\"en\", \"ru\")),  # For Ramifice by default = [\"en\", \"ru\"]\n)\n</code></pre> <pre><code>cd project_name\n# Add your custom translations:\nuv run pybabel extract -o config/translations/custom.pot src\nuv run pybabel init -i config/translations/custom.pot -d config/translations/custom -l en\nuv run pybabel init -i config/translations/custom.pot -d config/translations/custom -l ru\n...\n# Hint: Do not forget to add translations for new languages.\nuv run pybabel compile -d config/translations/custom\n\n# Update your custom translations:\nuv run pybabel extract -o config/translations/custom.pot src\nuv run pybabel update -i config/translations/custom.pot -d config/translations/custom\n# Hint: Do not forget to check the translations for existing languages.\nuv run pybabel compile -d config/translations/custom\n</code></pre>"},{"location":"pages/localization/#how-to-add-new-languages-to-ramifice-","title":"How to add new languages \u200b\u200bto Ramifice ?","text":"<pre><code>from ramifice import translations\n\ntranslations.add_languages(\n    default_locale=\"en\",  # For Ramifice by default = \"en\"\n    languages=frozenset((\"en\", \"ru\", \"de\", \"de_ch\")),  # For Ramifice by default = [\"en\", \"ru\"]\n)\n</code></pre> <pre><code>cd project_name\n# Example:\nuv run pybabel init -i config/translations/ramifice.pot -d config/translations/ramifice -l de\nuv run pybabel init -i config/translations/ramifice.pot -d config/translations/ramifice -l de_ch\n...\n# Hint: Do not forget to add translations for new languages.\nuv run pybabel compile -d config/translations/ramifice\n\n# Update translations to Ramifice:\nuv run pybabel extract -o config/translations/ramifice.pot ramifice\nuv run pybabel update -i config/translations/ramifice.pot -d config/translations/ramifice\n# Hint: Do not forget to check the translations for existing languages.\nuv run pybabel compile -d config/translations/ramifice\n</code></pre>"},{"location":"pages/models/","title":"Models","text":"<p>Models.</p> <p>This module provides:</p> <ul> <li><code>Model</code>: Converting Python classes into Ramifice Models.</li> <li><code>model</code>: Decorator for converting Python classes into Ramifice models.</li> </ul>"},{"location":"pages/models/#model-parameters","title":"Model Parameters","text":"<p>See the documentation.</p> <p>( only <code>service_name</code> is a required parameter )</p> Parameter Default Description service_name no Examples: Accounts | Smartphones | Washing machines | etc ...  fixture_name None           The name of the fixture in the config/fixtures directory (without extension).           Examples: SiteSettings | AppSettings | etc ...         db_query_docs_limit 1000 limiting query results. is_create_doc True           Can a Model create new documents in a collection?          Set to False if you only need one document in the collection and the Model is using a fixture.         is_update_doc True Can a Model update documents in a collection? is_delete_doc True Can a Model remove documents from a collection? <p></p> <p>Example:</p> <pre><code>@model(\n    service_name=\"ServiceName\",\n    fixture_name=\"FixtureName\",\n    db_query_docs_limit=1000,\n    is_create_doc = True,\n    is_update_doc = True,\n    is_delete_doc = True,\n)\nclass User:\n    def fields(self):\n        self.username = TextField(\n            label=gettext(\"Username\"),\n            required=True,\n            unique=True,\n        )\n</code></pre>"},{"location":"pages/models/decorator/","title":"Decorator","text":"<p>Decorator for converting Python classes into Ramifice models.</p>"},{"location":"pages/models/decorator/#ramifice.models.decorator.caching","title":"<code>caching(cls, service_name)</code>","text":"<p>Add additional metadata to <code>Model.META</code>.</p> Source code in <code>src/ramifice/models/decorator.py</code> <pre><code>def caching(cls: Any, service_name: str) -&gt; dict[str, Any]:\n    \"\"\"Add additional metadata to `Model.META`.\"\"\"\n    metadata: dict[str, Any] = {}\n    model_name: str = cls.__name__\n    if REGEX[\"model_name\"].match(model_name) is None:\n        regex_str: str = \"^[A-Z][a-zA-Z0-9]{0,24}$\"\n        msg = f\"Does not match the regular expression: {regex_str}\"\n        logger.critical(msg)\n        raise DoesNotMatchRegexError(regex_str)\n    #\n    metadata[\"model_name\"] = model_name\n    metadata[\"full_model_name\"] = f\"{cls.__module__}.{model_name}\"\n    metadata[\"collection_name\"] = f\"{service_name}_{model_name}\"\n    # Get a dictionary of field names and types.\n    # Format: &lt;field_name, field_type&gt;\n    field_name_and_type: dict[str, str] = {}\n    # Get attributes value for fields of Model: id, name.\n    field_attrs: dict[str, dict[str, str]] = {}\n    # Build data migration storage for dynamic fields.\n    data_dynamic_fields: dict[str, dict[str, str | int | float] | None] = {}\n    # Count all fields.\n    count_all_fields: int = 0\n    # Count fields for migrating.\n    count_fields_no_ignored: int = 0\n    # List of fields that support localization of translates.\n    # Hint: `TextField`\n    supported_lang_fields: list[str] = []\n\n    raw_model = cls()\n    raw_model.fields()\n    default_fields: dict[str, Any] = {\n        \"_id\": IDField(),\n        \"created_at\": DateTimeField(),\n        \"updated_at\": DateTimeField(),\n    }\n    fields = {**raw_model.__dict__, **default_fields}\n    for f_name, f_data in fields.items():\n        if not callable(f_data):\n            f_type_str = f_data.__class__.__name__\n            # Count all fields.\n            count_all_fields += 1\n            # Get attributes value for fields of Model: id, name.\n            field_attrs[f_name] = {\n                \"id\": f\"{model_name}--{f_name.replace('_', '-') if f_name != '_id' else 'id'}\",\n                \"name\": f_name,\n            }\n            #\n            if not f_data.ignored:\n                # Count fields for migrating.\n                count_fields_no_ignored += 1\n                # Get a dictionary of field names and types.\n                field_name_and_type[f_name] = f_type_str\n                # Build data migration storage for dynamic fields.\n                if \"Dyn\" in f_data.field_type:\n                    data_dynamic_fields[f_name] = None\n                if f_data.field_type == \"TextField\" and f_data.multi_language:\n                    supported_lang_fields.append(f_name)\n\n    metadata[\"field_name_and_type\"] = field_name_and_type\n    metadata[\"field_attrs\"] = field_attrs\n    metadata[\"data_dynamic_fields\"] = data_dynamic_fields\n    metadata[\"count_all_fields\"] = count_all_fields\n    metadata[\"count_fields_no_ignored\"] = count_fields_no_ignored\n    metadata[\"regex_mongo_filter\"] = re.compile(rf'(?P&lt;field&gt;\"(?:{\"|\".join(supported_lang_fields)})\":)')\n\n    return metadata\n</code></pre>"},{"location":"pages/models/decorator/#ramifice.models.decorator.model","title":"<code>model(service_name, fixture_name=None, db_query_docs_limit=1000, is_create_doc=True, is_update_doc=True, is_delete_doc=True)</code>","text":"<p>Decorator for converting Python Classe into Ramifice Model.</p> Source code in <code>src/ramifice/models/decorator.py</code> <pre><code>def model(\n    service_name: str,\n    fixture_name: str | None = None,\n    db_query_docs_limit: int = 1000,\n    is_create_doc: bool = True,\n    is_update_doc: bool = True,\n    is_delete_doc: bool = True,\n) -&gt; Any:\n    \"\"\"Decorator for converting Python Classe into Ramifice Model.\"\"\"\n    try:\n        if not isinstance(service_name, str):\n            msg = \"Parameter `service_name` - Must be `str` type!\"\n            raise AssertionError(msg)\n        if not isinstance(fixture_name, (str, type(None))):\n            msg = \"Parameter `fixture_name` - Must be `str | None` type!\"\n            raise AssertionError(msg)\n        if not isinstance(db_query_docs_limit, int):\n            msg = \"Parameter `db_query_docs_limit` - Must be `int` type!\"\n            raise AssertionError(msg)\n        if not isinstance(is_create_doc, bool):\n            msg = \"Parameter `is_create_doc` - Must be `bool` type!\"\n            raise AssertionError(msg)\n        if not isinstance(is_update_doc, bool):\n            msg = \"Parameter `is_update_doc` - Must be `bool` type!\"\n            raise AssertionError(msg)\n        if not isinstance(is_delete_doc, bool):\n            msg = \"Parameter `is_delete_doc` - Must be `bool` type!\"\n            raise AssertionError(msg)\n    except AssertionError as err:\n        logger.critical(str(err))\n        raise err\n\n    def decorator(cls: Any) -&gt; Any:\n        if REGEX[\"service_name\"].match(service_name) is None:\n            regex_str: str = \"^[A-Z][a-zA-Z0-9]{0,24}$\"\n            msg = f\"Does not match the regular expression: {regex_str}\"\n            logger.critical(msg)\n            raise DoesNotMatchRegexError(regex_str)\n        if fixture_name is not None:\n            fixture_path = f\"config/fixtures/{fixture_name}.yml\"\n\n            if not Path(fixture_path).exists():\n                msg = (\n                    f\"Model: `{cls.__module__}.{cls.__name__}` &gt; \"\n                    + \"META param: `fixture_name` =&gt; \"\n                    + f\"Fixture the `{fixture_path}` not exists!\"\n                )\n                logger.critical(msg)\n                raise PanicError(msg)\n\n        attrs = dict(cls.__dict__)\n        attrs[\"__dict__\"] = Model.__dict__[\"__dict__\"]\n        metadata = {\n            \"service_name\": service_name,\n            \"fixture_name\": fixture_name,\n            \"db_query_docs_limit\": db_query_docs_limit,\n            \"is_create_doc\": is_create_doc,\n            \"is_update_doc\": is_update_doc,\n            \"is_delete_doc\": is_delete_doc,\n        }\n        attrs[\"META\"] = {\n            **metadata,\n            **caching(cls, service_name),\n        }\n\n        return type(\n            cls.__name__,\n            (\n                Model,\n                QPaladinsMixin,\n                QCommonsMixin,\n            ),\n            attrs,\n        )\n\n    return decorator\n</code></pre>"},{"location":"pages/models/model/","title":"Model","text":"<p>Converting Python classes into Ramifice Models.</p>"},{"location":"pages/models/model/#ramifice.models.model.Model","title":"<code>Model</code>","text":"<p>Converting Python Class into Ramifice Model.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>class Model:\n    \"\"\"Converting Python Class into Ramifice Model.\"\"\"\n\n    META: ClassVar[dict[str, Any]] = {}\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        _ = translations._\n        self._id = IDField(\n            label=_(\"Document ID\"),\n            placeholder=_(\"It is added automatically\"),\n            hint=_(\"It is added automatically\"),\n            hide=True,\n            disabled=True,\n        )\n        self.created_at = DateTimeField(\n            label=_(\"Created at\"),\n            placeholder=_(\"It is added automatically\"),\n            hint=_(\"It is added automatically\"),\n            warning=[_(\"When the document was created.\")],\n            hide=True,\n            disabled=True,\n        )\n        self.updated_at = DateTimeField(\n            label=_(\"Updated at\"),\n            placeholder=_(\"It is added automatically\"),\n            hint=_(\"It is added automatically\"),\n            warning=[_(\"When the document was updated.\")],\n            hide=True,\n            disabled=True,\n        )\n        self.fields()\n        self.inject()\n\n    @property\n    def id(self) -&gt; IDField:\n        \"\"\"Getter for the field `_id`.\"\"\"\n        return self._id\n\n    @abstractmethod\n    def fields(self) -&gt; None:\n        \"\"\"Adding fields.\"\"\"\n\n    def model_name(self) -&gt; str:\n        \"\"\"Get Model name - Class name.\"\"\"\n        return self.__class__.__name__\n\n    def full_model_name(self) -&gt; str:\n        \"\"\"Get full Model name - module_name + . + ClassName.\"\"\"\n        cls = self.__class__\n        return f\"{cls.__module__}.{cls.__name__}\"\n\n    def inject(self) -&gt; None:\n        \"\"\"Injecting metadata from Model.META in params of fields.\"\"\"\n        metadata = self.__class__.META\n        if bool(metadata):\n            lang = translations.CURRENT_LOCALE\n            field_attrs = metadata[\"field_attrs\"]\n            data_dynamic_fields = metadata[\"data_dynamic_fields\"]\n            for f_name, f_type in self.__dict__.items():\n                if not callable(f_type):\n                    f_type.id = field_attrs[f_name][\"id\"]\n                    f_type.name = field_attrs[f_name][\"name\"]\n                    if \"Dyn\" in f_type.field_type:\n                        dyn_data = data_dynamic_fields[f_name]\n                        if dyn_data is not None:\n                            f_type.choices = [[item[\"value\"], item[\"title\"][lang]] for item in dyn_data]\n                        else:\n                            # This is necessary for\n                            # `paladins &gt; refrash &gt; RefrashMixin &gt; refrash_from_db`.\n                            f_type.choices = None\n\n    # Complect of methods for converting Model to JSON and back.\n    # --------------------------------------------------------------------------\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert object instance to a dictionary.\"\"\"\n        json_dict: dict[str, Any] = {}\n        for name, data in self.__dict__.items():\n            if not callable(data):\n                json_dict[name] = data.to_dict()\n        return json_dict\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object instance to a JSON string.\"\"\"\n        return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n\n    @classmethod\n    def from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        obj = cls()\n        for name, data in json_dict.items():\n            obj.__dict__[name] = obj.__dict__[name].__class__.from_dict(data)\n        return obj\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        json_dict = orjson.loads(json_str)\n        return cls.from_dict(json_dict)\n\n    # --------------------------------------------------------------------------\n    def to_dict_only_value(self) -&gt; dict[str, Any]:\n        \"\"\"Convert model.field.value (only the `value` attribute) to a dictionary.\"\"\"\n        json_dict: dict[str, Any] = {}\n        current_locale = translations.CURRENT_LOCALE\n        for name, data in self.__dict__.items():\n            if callable(data):\n                continue\n            value = data.value\n            if value is not None:\n                group = data.group\n                if group == \"date\":\n                    value = (\n                        format_date(\n                            date=value,\n                            format=\"short\",\n                            locale=current_locale,\n                        )\n                        if data.field_type == \"DateField\"\n                        else format_datetime(\n                            datetime=value,\n                            format=\"short\",\n                            locale=current_locale,\n                        )\n                    )\n                elif group == \"id\":\n                    value = str(value)\n                elif group == \"pass\":\n                    value = None\n            json_dict[name] = value\n        return json_dict\n\n    def to_json_only_value(self) -&gt; str:\n        \"\"\"Convert model.field.value (only the `value` attribute) to a JSON string.\"\"\"\n        return orjson.dumps(self.to_dict_only_value()).decode(\"utf-8\")\n\n    @classmethod\n    def from_dict_only_value(cls, json_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        obj = cls()\n        for name, data in obj.__dict__.items():\n            if callable(data):\n                continue\n            value = json_dict.get(name)\n            if value is not None:\n                group = data.group\n                if group == \"date\":\n                    value = parse(value)\n                elif group == \"id\":\n                    value = ObjectId(value)\n            obj.__dict__[name].value = value\n        return obj\n\n    @classmethod\n    def from_json_only_value(cls, json_str: str) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        json_dict = orjson.loads(json_str)\n        return cls.from_dict_only_value(json_dict)\n\n    def refrash_fields_only_value(self, only_value_dict: dict[str, Any]) -&gt; None:\n        \"\"\"Partial or complete update a `value` of fields.\"\"\"\n        for name, data in self.__dict__.items():\n            if callable(data):\n                continue\n            value = only_value_dict.get(name)\n            if value is not None:\n                group = data.group\n                if group == \"date\":\n                    value = parse(value)\n                elif group == \"id\":\n                    value = ObjectId(value)\n            self.__dict__[name].value = value\n\n    # --------------------------------------------------------------------------\n    def get_clean_data(self) -&gt; tuple[NamedTuple, NamedTuple]:\n        \"\"\"Get clean data.\"\"\"\n        clean_data: dict[str, Any] = {}\n        error_map: dict[str, Any] = {}\n\n        for name, data in self.__dict__.items():\n            if not callable(data):\n                clean_data[name] = data.value\n                error_map[name] = None\n\n        return (NamedTuple(**clean_data), NamedTuple(**error_map))\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.id","title":"<code>id</code>  <code>property</code>","text":"<p>Getter for the field <code>_id</code>.</p>"},{"location":"pages/models/model/#ramifice.models.model.Model.fields","title":"<code>fields()</code>  <code>abstractmethod</code>","text":"<p>Adding fields.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>@abstractmethod\ndef fields(self) -&gt; None:\n    \"\"\"Adding fields.\"\"\"\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.from_dict","title":"<code>from_dict(json_dict)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>@classmethod\ndef from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    obj = cls()\n    for name, data in json_dict.items():\n        obj.__dict__[name] = obj.__dict__[name].__class__.from_dict(data)\n    return obj\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.from_dict_only_value","title":"<code>from_dict_only_value(json_dict)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>@classmethod\ndef from_dict_only_value(cls, json_dict: dict[str, Any]) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    obj = cls()\n    for name, data in obj.__dict__.items():\n        if callable(data):\n            continue\n        value = json_dict.get(name)\n        if value is not None:\n            group = data.group\n            if group == \"date\":\n                value = parse(value)\n            elif group == \"id\":\n                value = ObjectId(value)\n        obj.__dict__[name].value = value\n    return obj\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    json_dict = orjson.loads(json_str)\n    return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.from_json_only_value","title":"<code>from_json_only_value(json_str)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>@classmethod\ndef from_json_only_value(cls, json_str: str) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    json_dict = orjson.loads(json_str)\n    return cls.from_dict_only_value(json_dict)\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.full_model_name","title":"<code>full_model_name()</code>","text":"<p>Get full Model name - module_name + . + ClassName.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def full_model_name(self) -&gt; str:\n    \"\"\"Get full Model name - module_name + . + ClassName.\"\"\"\n    cls = self.__class__\n    return f\"{cls.__module__}.{cls.__name__}\"\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.get_clean_data","title":"<code>get_clean_data()</code>","text":"<p>Get clean data.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def get_clean_data(self) -&gt; tuple[NamedTuple, NamedTuple]:\n    \"\"\"Get clean data.\"\"\"\n    clean_data: dict[str, Any] = {}\n    error_map: dict[str, Any] = {}\n\n    for name, data in self.__dict__.items():\n        if not callable(data):\n            clean_data[name] = data.value\n            error_map[name] = None\n\n    return (NamedTuple(**clean_data), NamedTuple(**error_map))\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.inject","title":"<code>inject()</code>","text":"<p>Injecting metadata from Model.META in params of fields.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def inject(self) -&gt; None:\n    \"\"\"Injecting metadata from Model.META in params of fields.\"\"\"\n    metadata = self.__class__.META\n    if bool(metadata):\n        lang = translations.CURRENT_LOCALE\n        field_attrs = metadata[\"field_attrs\"]\n        data_dynamic_fields = metadata[\"data_dynamic_fields\"]\n        for f_name, f_type in self.__dict__.items():\n            if not callable(f_type):\n                f_type.id = field_attrs[f_name][\"id\"]\n                f_type.name = field_attrs[f_name][\"name\"]\n                if \"Dyn\" in f_type.field_type:\n                    dyn_data = data_dynamic_fields[f_name]\n                    if dyn_data is not None:\n                        f_type.choices = [[item[\"value\"], item[\"title\"][lang]] for item in dyn_data]\n                    else:\n                        # This is necessary for\n                        # `paladins &gt; refrash &gt; RefrashMixin &gt; refrash_from_db`.\n                        f_type.choices = None\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.model_name","title":"<code>model_name()</code>","text":"<p>Get Model name - Class name.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def model_name(self) -&gt; str:\n    \"\"\"Get Model name - Class name.\"\"\"\n    return self.__class__.__name__\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.refrash_fields_only_value","title":"<code>refrash_fields_only_value(only_value_dict)</code>","text":"<p>Partial or complete update a <code>value</code> of fields.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def refrash_fields_only_value(self, only_value_dict: dict[str, Any]) -&gt; None:\n    \"\"\"Partial or complete update a `value` of fields.\"\"\"\n    for name, data in self.__dict__.items():\n        if callable(data):\n            continue\n        value = only_value_dict.get(name)\n        if value is not None:\n            group = data.group\n            if group == \"date\":\n                value = parse(value)\n            elif group == \"id\":\n                value = ObjectId(value)\n        self.__dict__[name].value = value\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert object instance to a dictionary.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert object instance to a dictionary.\"\"\"\n    json_dict: dict[str, Any] = {}\n    for name, data in self.__dict__.items():\n        if not callable(data):\n            json_dict[name] = data.to_dict()\n    return json_dict\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.to_dict_only_value","title":"<code>to_dict_only_value()</code>","text":"<p>Convert model.field.value (only the <code>value</code> attribute) to a dictionary.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def to_dict_only_value(self) -&gt; dict[str, Any]:\n    \"\"\"Convert model.field.value (only the `value` attribute) to a dictionary.\"\"\"\n    json_dict: dict[str, Any] = {}\n    current_locale = translations.CURRENT_LOCALE\n    for name, data in self.__dict__.items():\n        if callable(data):\n            continue\n        value = data.value\n        if value is not None:\n            group = data.group\n            if group == \"date\":\n                value = (\n                    format_date(\n                        date=value,\n                        format=\"short\",\n                        locale=current_locale,\n                    )\n                    if data.field_type == \"DateField\"\n                    else format_datetime(\n                        datetime=value,\n                        format=\"short\",\n                        locale=current_locale,\n                    )\n                )\n            elif group == \"id\":\n                value = str(value)\n            elif group == \"pass\":\n                value = None\n        json_dict[name] = value\n    return json_dict\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.to_json","title":"<code>to_json()</code>","text":"<p>Convert object instance to a JSON string.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert object instance to a JSON string.\"\"\"\n    return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n</code></pre>"},{"location":"pages/models/model/#ramifice.models.model.Model.to_json_only_value","title":"<code>to_json_only_value()</code>","text":"<p>Convert model.field.value (only the <code>value</code> attribute) to a JSON string.</p> Source code in <code>src/ramifice/models/model.py</code> <pre><code>def to_json_only_value(self) -&gt; str:\n    \"\"\"Convert model.field.value (only the `value` attribute) to a JSON string.\"\"\"\n    return orjson.dumps(self.to_dict_only_value()).decode(\"utf-8\")\n</code></pre>"},{"location":"pages/paladins/","title":"Paladins","text":"<p>Paladins - Model instance methods.</p> <p>This module provides:</p> <ul> <li><code>add_validation</code>: Contains an abstract method for additional validation of fields.</li> <li><code>check</code>: Validation of Model data before saving to the database.</li> <li><code>delete</code>: Delete document from database.</li> <li><code>Hooks</code>: A set of abstract methods for creating hooks.</li> <li><code>indexing</code>: Contains the method for indexing the model in the database.</li> <li><code>password</code>: Verification, replacement and recoverang of password.</li> <li><code>refrash_from_db</code>: Update Model instance from database.</li> <li><code>save</code>: Create or update document in database.</li> <li><code>Tools</code>: A set of auxiliary methods.</li> <li><code>is_valid</code>: Validation of Model.</li> <li><code>print_err</code>: Printing errors to console.</li> </ul>"},{"location":"pages/paladins/add_valid/","title":"Add Validation","text":"<p>AddValidMixin - Contains an abstract method for additional validation of fields.</p>"},{"location":"pages/paladins/add_valid/#ramifice.paladins.add_valid.AddValidMixin","title":"<code>AddValidMixin</code>","text":"<p>Contains an abstract method for additional validation of fields.</p> Source code in <code>src/ramifice/paladins/add_valid.py</code> <pre><code>class AddValidMixin:\n    \"\"\"Contains an abstract method for additional validation of fields.\"\"\"\n\n    @abstractmethod\n    async def add_validation(self) -&gt; NamedTuple:\n        \"\"\"Additional validation of fields.\"\"\"\n        return NamedTuple()\n</code></pre>"},{"location":"pages/paladins/add_valid/#ramifice.paladins.add_valid.AddValidMixin.add_validation","title":"<code>add_validation()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Additional validation of fields.</p> Source code in <code>src/ramifice/paladins/add_valid.py</code> <pre><code>@abstractmethod\nasync def add_validation(self) -&gt; NamedTuple:\n    \"\"\"Additional validation of fields.\"\"\"\n    return NamedTuple()\n</code></pre>"},{"location":"pages/paladins/check/","title":"Check","text":"<p>Validation of Model data before saving to the database.</p>"},{"location":"pages/paladins/check/#ramifice.paladins.check.CheckMixin","title":"<code>CheckMixin</code>","text":"<p>               Bases: <code>BoolGroupMixin</code>, <code>ChoiceGroupMixin</code>, <code>DateGroupMixin</code>, <code>FileGroupMixin</code>, <code>IDGroupMixin</code>, <code>ImgGroupMixin</code>, <code>NumGroupMixin</code>, <code>PassGroupMixin</code>, <code>SlugGroupMixin</code>, <code>TextGroupMixin</code></p> <p>Validation of Model data before saving to the database.</p> Source code in <code>src/ramifice/paladins/check.py</code> <pre><code>class CheckMixin(\n    BoolGroupMixin,\n    ChoiceGroupMixin,\n    DateGroupMixin,\n    FileGroupMixin,\n    IDGroupMixin,\n    ImgGroupMixin,\n    NumGroupMixin,\n    PassGroupMixin,\n    SlugGroupMixin,\n    TextGroupMixin,\n):\n    \"\"\"Validation of Model data before saving to the database.\"\"\"\n\n    async def check(\n        self,\n        is_save: bool = False,\n        collection: AsyncCollection | None = None,\n        is_migration_process: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Validation of Model data before saving to the database.\n\n        It is also used to verify Models that do not migrate to the database.\n        \"\"\"\n        cls_model = self.__class__\n\n        # Get the document ID.\n        doc_id: ObjectId | None = self._id.value\n        # Does the document exist in the database?\n        is_update: bool = doc_id is not None\n        # Create an identifier for a new document.\n        if is_save and not is_update:\n            doc_id = ObjectId()\n            self._id.value = doc_id\n\n        result_map: dict[str, Any] = {}\n        # Errors from additional validation of fields.\n        error_map: dict[str, str] = await self.add_validation()\n        # Get Model collection.\n        if collection is None:\n            collection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n        # Create params for *_group methods.\n        params: dict[str, Any] = {\n            \"doc_id\": doc_id,\n            \"is_save\": is_save,\n            \"is_update\": is_update,  # Does the document exist in the database?\n            \"is_error_symptom\": False,  # Is there any incorrect data?\n            \"result_map\": result_map,  # Data to save or update to the database.\n            \"collection\": collection,\n            \"field_data\": None,\n            \"full_model_name\": cls_model.META[\"full_model_name\"],\n            \"is_migration_process\": is_migration_process,\n            \"curr_doc\": (await collection.find_one({\"_id\": doc_id}) if is_save and is_update else None),\n        }\n\n        # Run checking fields.\n        for field_name, field_data in self.__dict__.items():\n            if callable(field_data):\n                continue\n            # Reset a field errors to exclude duplicates.\n            field_data.errors = []\n            # Check additional validation.\n            err_msg = error_map.get(field_name)\n            if bool(err_msg):\n                field_data.errors.append(err_msg)\n                if not params[\"is_error_symptom\"]:\n                    params[\"is_error_symptom\"] = True\n            # Checking the fields by groups.\n            if not field_data.ignored:\n                params[\"field_data\"] = field_data\n                match field_data.group:\n                    case \"text\":\n                        await self.text_group(params)\n                    case \"num\":\n                        await self.num_group(params)\n                    case \"date\":\n                        self.date_group(params)\n                    case \"img\":\n                        await self.img_group(params)\n                    case \"file\":\n                        await self.file_group(params)\n                    case \"choice\":\n                        self.choice_group(params)\n                    case \"bool\":\n                        self.bool_group(params)\n                    case \"id\":\n                        self.id_group(params)\n                    case \"slug\":\n                        await self.slug_group(params)\n                    case \"pass\":\n                        self.pass_group(params)\n                    case _ as unreachable:\n                        msg: str = f\"Unacceptable group `{unreachable}`!\"\n                        logger.critical(msg)\n                        assert_never(unreachable)\n\n        # Actions in case of error.\n        if is_save:\n            if params[\"is_error_symptom\"]:\n                # Reset the ObjectId for a new document.\n                if not is_update:\n                    self._id.value = None\n                # Delete orphaned files.\n                curr_doc: dict[str, Any] | None = params[\"curr_doc\"]\n                for field_name, field_data in self.__dict__.items():\n                    if callable(field_data) or field_data.ignored:\n                        continue\n                    match field_data.group:\n                        case \"file\":\n                            file_data = result_map.get(field_name)\n                            if file_data is not None:\n                                if file_data[\"is_new_file\"]:\n                                    await to_thread.run_sync(remove, file_data[\"path\"])\n                                field_data.value = None\n                            if curr_doc is not None:\n                                field_data.value = curr_doc[field_name]\n                        case \"img\":\n                            img_data = result_map.get(field_name)\n                            if img_data is not None:\n                                if img_data[\"is_new_img\"]:\n                                    await to_thread.run_sync(rmtree, img_data[\"imgs_dir_path\"])\n                                field_data.value = None\n                            if curr_doc is not None:\n                                field_data.value = curr_doc[field_name]\n            else:\n                for field_name, field_data in self.__dict__.items():\n                    if callable(field_data) or field_data.ignored:\n                        continue\n                    match field_data.group:\n                        case \"file\":\n                            file_data = result_map.get(field_name)\n                            if file_data is not None:\n                                file_data[\"is_new_file\"] = False\n                        case \"img\":\n                            img_data = result_map.get(field_name)\n                            if img_data is not None:\n                                img_data[\"is_new_img\"] = False\n        #\n        return {\n            \"data\": result_map,\n            \"is_valid\": not params[\"is_error_symptom\"],\n            \"is_update\": is_update,\n        }\n</code></pre>"},{"location":"pages/paladins/check/#ramifice.paladins.check.CheckMixin.check","title":"<code>check(is_save=False, collection=None, is_migration_process=False)</code>  <code>async</code>","text":"<p>Validation of Model data before saving to the database.</p> <p>It is also used to verify Models that do not migrate to the database.</p> Source code in <code>src/ramifice/paladins/check.py</code> <pre><code>async def check(\n    self,\n    is_save: bool = False,\n    collection: AsyncCollection | None = None,\n    is_migration_process: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"Validation of Model data before saving to the database.\n\n    It is also used to verify Models that do not migrate to the database.\n    \"\"\"\n    cls_model = self.__class__\n\n    # Get the document ID.\n    doc_id: ObjectId | None = self._id.value\n    # Does the document exist in the database?\n    is_update: bool = doc_id is not None\n    # Create an identifier for a new document.\n    if is_save and not is_update:\n        doc_id = ObjectId()\n        self._id.value = doc_id\n\n    result_map: dict[str, Any] = {}\n    # Errors from additional validation of fields.\n    error_map: dict[str, str] = await self.add_validation()\n    # Get Model collection.\n    if collection is None:\n        collection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n    # Create params for *_group methods.\n    params: dict[str, Any] = {\n        \"doc_id\": doc_id,\n        \"is_save\": is_save,\n        \"is_update\": is_update,  # Does the document exist in the database?\n        \"is_error_symptom\": False,  # Is there any incorrect data?\n        \"result_map\": result_map,  # Data to save or update to the database.\n        \"collection\": collection,\n        \"field_data\": None,\n        \"full_model_name\": cls_model.META[\"full_model_name\"],\n        \"is_migration_process\": is_migration_process,\n        \"curr_doc\": (await collection.find_one({\"_id\": doc_id}) if is_save and is_update else None),\n    }\n\n    # Run checking fields.\n    for field_name, field_data in self.__dict__.items():\n        if callable(field_data):\n            continue\n        # Reset a field errors to exclude duplicates.\n        field_data.errors = []\n        # Check additional validation.\n        err_msg = error_map.get(field_name)\n        if bool(err_msg):\n            field_data.errors.append(err_msg)\n            if not params[\"is_error_symptom\"]:\n                params[\"is_error_symptom\"] = True\n        # Checking the fields by groups.\n        if not field_data.ignored:\n            params[\"field_data\"] = field_data\n            match field_data.group:\n                case \"text\":\n                    await self.text_group(params)\n                case \"num\":\n                    await self.num_group(params)\n                case \"date\":\n                    self.date_group(params)\n                case \"img\":\n                    await self.img_group(params)\n                case \"file\":\n                    await self.file_group(params)\n                case \"choice\":\n                    self.choice_group(params)\n                case \"bool\":\n                    self.bool_group(params)\n                case \"id\":\n                    self.id_group(params)\n                case \"slug\":\n                    await self.slug_group(params)\n                case \"pass\":\n                    self.pass_group(params)\n                case _ as unreachable:\n                    msg: str = f\"Unacceptable group `{unreachable}`!\"\n                    logger.critical(msg)\n                    assert_never(unreachable)\n\n    # Actions in case of error.\n    if is_save:\n        if params[\"is_error_symptom\"]:\n            # Reset the ObjectId for a new document.\n            if not is_update:\n                self._id.value = None\n            # Delete orphaned files.\n            curr_doc: dict[str, Any] | None = params[\"curr_doc\"]\n            for field_name, field_data in self.__dict__.items():\n                if callable(field_data) or field_data.ignored:\n                    continue\n                match field_data.group:\n                    case \"file\":\n                        file_data = result_map.get(field_name)\n                        if file_data is not None:\n                            if file_data[\"is_new_file\"]:\n                                await to_thread.run_sync(remove, file_data[\"path\"])\n                            field_data.value = None\n                        if curr_doc is not None:\n                            field_data.value = curr_doc[field_name]\n                    case \"img\":\n                        img_data = result_map.get(field_name)\n                        if img_data is not None:\n                            if img_data[\"is_new_img\"]:\n                                await to_thread.run_sync(rmtree, img_data[\"imgs_dir_path\"])\n                            field_data.value = None\n                        if curr_doc is not None:\n                            field_data.value = curr_doc[field_name]\n        else:\n            for field_name, field_data in self.__dict__.items():\n                if callable(field_data) or field_data.ignored:\n                    continue\n                match field_data.group:\n                    case \"file\":\n                        file_data = result_map.get(field_name)\n                        if file_data is not None:\n                            file_data[\"is_new_file\"] = False\n                    case \"img\":\n                        img_data = result_map.get(field_name)\n                        if img_data is not None:\n                            img_data[\"is_new_img\"] = False\n    #\n    return {\n        \"data\": result_map,\n        \"is_valid\": not params[\"is_error_symptom\"],\n        \"is_update\": is_update,\n    }\n</code></pre>"},{"location":"pages/paladins/delete/","title":"Delete","text":"<p>Delete document from database.</p>"},{"location":"pages/paladins/delete/#ramifice.paladins.delete.DeleteMixin","title":"<code>DeleteMixin</code>","text":"<p>Delete document from database.</p> Source code in <code>src/ramifice/paladins/delete.py</code> <pre><code>class DeleteMixin:\n    \"\"\"Delete document from database.\"\"\"\n\n    async def delete(\n        self,\n        remove_files: bool = True,\n        projection: Any | None = None,\n        sort: Any | None = None,\n        hint: Any | None = None,\n        session: Any | None = None,\n        let: Any | None = None,\n        comment: Any | None = None,\n        **kwargs: dict[str, Any],\n    ) -&gt; dict[str, Any]:\n        \"\"\"Delete document from database.\"\"\"\n        cls_model = self.__class__\n        # Raises a panic if the Model cannot be removed.\n        if not cls_model.META[\"is_delete_doc\"]:\n            msg = (\n                f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n                + \"META param: `is_delete_doc` (False) =&gt; \"\n                + \"Documents of this Model cannot be removed from the database!\"\n            )\n            logger.warning(msg)\n            raise ForbiddenDeleteDocError(msg)\n        # Get documet ID.\n        doc_id = self._id.value\n        if doc_id is None:\n            msg = (\n                f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n                + \"Field: `_id` &gt; \"\n                + \"Param: `value` =&gt; ID is missing.\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n        # Run hook.\n        await self.pre_delete()\n        # Get collection for current Model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n        # Delete document.\n        mongo_doc: dict[str, Any] = {}\n        mongo_doc = await collection.find_one_and_delete(\n            filter={\"_id\": doc_id},\n            projection=projection,\n            sort=sort,\n            hint=hint,\n            session=session,\n            let=let,\n            comment=comment,\n            **kwargs,\n        )\n        # If the document failed to delete.\n        if not bool(mongo_doc):\n            msg = (\n                f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n                + \"Method: `delete` =&gt; \"\n                + \"The document was not deleted, the document is absent in the database.\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n        # Delete orphaned files and add None to field.value.\n        file_data: dict[str, Any] | None = None\n        for field_name, field_data in self.__dict__.items():\n            if callable(field_data):\n                continue\n            if remove_files and not field_data.ignored:\n                group = field_data.group\n                if group == \"file\":\n                    file_data = mongo_doc[field_name]\n                    if file_data is not None and len(file_data[\"path\"]) &gt; 0:\n                        await to_thread.run_sync(remove, file_data[\"path\"])\n                    file_data = None\n                elif group == \"img\":\n                    file_data = mongo_doc[field_name]\n                    if file_data is not None and len(file_data[\"imgs_dir_path\"]) &gt; 0:\n                        await to_thread.run_sync(rmtree, file_data[\"imgs_dir_path\"])\n                    file_data = None\n            field_data.value = None\n        # Run hook.\n        await self.post_delete()\n        #\n        return mongo_doc\n</code></pre>"},{"location":"pages/paladins/delete/#ramifice.paladins.delete.DeleteMixin.delete","title":"<code>delete(remove_files=True, projection=None, sort=None, hint=None, session=None, let=None, comment=None, **kwargs)</code>  <code>async</code>","text":"<p>Delete document from database.</p> Source code in <code>src/ramifice/paladins/delete.py</code> <pre><code>async def delete(\n    self,\n    remove_files: bool = True,\n    projection: Any | None = None,\n    sort: Any | None = None,\n    hint: Any | None = None,\n    session: Any | None = None,\n    let: Any | None = None,\n    comment: Any | None = None,\n    **kwargs: dict[str, Any],\n) -&gt; dict[str, Any]:\n    \"\"\"Delete document from database.\"\"\"\n    cls_model = self.__class__\n    # Raises a panic if the Model cannot be removed.\n    if not cls_model.META[\"is_delete_doc\"]:\n        msg = (\n            f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n            + \"META param: `is_delete_doc` (False) =&gt; \"\n            + \"Documents of this Model cannot be removed from the database!\"\n        )\n        logger.warning(msg)\n        raise ForbiddenDeleteDocError(msg)\n    # Get documet ID.\n    doc_id = self._id.value\n    if doc_id is None:\n        msg = (\n            f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n            + \"Field: `_id` &gt; \"\n            + \"Param: `value` =&gt; ID is missing.\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n    # Run hook.\n    await self.pre_delete()\n    # Get collection for current Model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n    # Delete document.\n    mongo_doc: dict[str, Any] = {}\n    mongo_doc = await collection.find_one_and_delete(\n        filter={\"_id\": doc_id},\n        projection=projection,\n        sort=sort,\n        hint=hint,\n        session=session,\n        let=let,\n        comment=comment,\n        **kwargs,\n    )\n    # If the document failed to delete.\n    if not bool(mongo_doc):\n        msg = (\n            f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n            + \"Method: `delete` =&gt; \"\n            + \"The document was not deleted, the document is absent in the database.\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n    # Delete orphaned files and add None to field.value.\n    file_data: dict[str, Any] | None = None\n    for field_name, field_data in self.__dict__.items():\n        if callable(field_data):\n            continue\n        if remove_files and not field_data.ignored:\n            group = field_data.group\n            if group == \"file\":\n                file_data = mongo_doc[field_name]\n                if file_data is not None and len(file_data[\"path\"]) &gt; 0:\n                    await to_thread.run_sync(remove, file_data[\"path\"])\n                file_data = None\n            elif group == \"img\":\n                file_data = mongo_doc[field_name]\n                if file_data is not None and len(file_data[\"imgs_dir_path\"]) &gt; 0:\n                    await to_thread.run_sync(rmtree, file_data[\"imgs_dir_path\"])\n                file_data = None\n        field_data.value = None\n    # Run hook.\n    await self.post_delete()\n    #\n    return mongo_doc\n</code></pre>"},{"location":"pages/paladins/hooks/","title":"Hooks","text":"<p>HooksMixin - Contains abstract methods for creating hooks.</p>"},{"location":"pages/paladins/hooks/#ramifice.paladins.hooks.HooksMixin","title":"<code>HooksMixin</code>","text":"<p>A set of abstract methods for creating hooks.</p> Source code in <code>src/ramifice/paladins/hooks.py</code> <pre><code>class HooksMixin:\n    \"\"\"A set of abstract methods for creating hooks.\"\"\"\n\n    @abstractmethod\n    async def pre_create(self) -&gt; None:\n        \"\"\"Called before a new document is created in the database.\"\"\"\n\n    @abstractmethod\n    async def post_create(self) -&gt; None:\n        \"\"\"Called after a new document has been created in the database.\"\"\"\n\n    @abstractmethod\n    async def pre_update(self) -&gt; None:\n        \"\"\"Called before updating an existing document in the database.\"\"\"\n\n    @abstractmethod\n    async def post_update(self) -&gt; None:\n        \"\"\"Called after an existing document in the database is updated.\"\"\"\n\n    @abstractmethod\n    async def pre_delete(self) -&gt; None:\n        \"\"\"Called before deleting an existing document in the database.\"\"\"\n\n    @abstractmethod\n    async def post_delete(self) -&gt; None:\n        \"\"\"Called after an existing document in the database has been deleted.\"\"\"\n</code></pre>"},{"location":"pages/paladins/hooks/#ramifice.paladins.hooks.HooksMixin.post_create","title":"<code>post_create()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Called after a new document has been created in the database.</p> Source code in <code>src/ramifice/paladins/hooks.py</code> <pre><code>@abstractmethod\nasync def post_create(self) -&gt; None:\n    \"\"\"Called after a new document has been created in the database.\"\"\"\n</code></pre>"},{"location":"pages/paladins/hooks/#ramifice.paladins.hooks.HooksMixin.post_delete","title":"<code>post_delete()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Called after an existing document in the database has been deleted.</p> Source code in <code>src/ramifice/paladins/hooks.py</code> <pre><code>@abstractmethod\nasync def post_delete(self) -&gt; None:\n    \"\"\"Called after an existing document in the database has been deleted.\"\"\"\n</code></pre>"},{"location":"pages/paladins/hooks/#ramifice.paladins.hooks.HooksMixin.post_update","title":"<code>post_update()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Called after an existing document in the database is updated.</p> Source code in <code>src/ramifice/paladins/hooks.py</code> <pre><code>@abstractmethod\nasync def post_update(self) -&gt; None:\n    \"\"\"Called after an existing document in the database is updated.\"\"\"\n</code></pre>"},{"location":"pages/paladins/hooks/#ramifice.paladins.hooks.HooksMixin.pre_create","title":"<code>pre_create()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Called before a new document is created in the database.</p> Source code in <code>src/ramifice/paladins/hooks.py</code> <pre><code>@abstractmethod\nasync def pre_create(self) -&gt; None:\n    \"\"\"Called before a new document is created in the database.\"\"\"\n</code></pre>"},{"location":"pages/paladins/hooks/#ramifice.paladins.hooks.HooksMixin.pre_delete","title":"<code>pre_delete()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Called before deleting an existing document in the database.</p> Source code in <code>src/ramifice/paladins/hooks.py</code> <pre><code>@abstractmethod\nasync def pre_delete(self) -&gt; None:\n    \"\"\"Called before deleting an existing document in the database.\"\"\"\n</code></pre>"},{"location":"pages/paladins/hooks/#ramifice.paladins.hooks.HooksMixin.pre_update","title":"<code>pre_update()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Called before updating an existing document in the database.</p> Source code in <code>src/ramifice/paladins/hooks.py</code> <pre><code>@abstractmethod\nasync def pre_update(self) -&gt; None:\n    \"\"\"Called before updating an existing document in the database.\"\"\"\n</code></pre>"},{"location":"pages/paladins/indexing/","title":"Indexing","text":"<p>IndexMixin - Contains abstract method for indexing the model in the database.</p>"},{"location":"pages/paladins/indexing/#ramifice.paladins.indexing.IndexMixin","title":"<code>IndexMixin</code>","text":"<p>Contains the method for indexing the model in the database.</p> Source code in <code>src/ramifice/paladins/indexing.py</code> <pre><code>class IndexMixin:\n    \"\"\"Contains the method for indexing the model in the database.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    async def indexing(cls) -&gt; None:\n        \"\"\"Set up and start indexing.\"\"\"\n</code></pre>"},{"location":"pages/paladins/indexing/#ramifice.paladins.indexing.IndexMixin.indexing","title":"<code>indexing()</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Set up and start indexing.</p> Source code in <code>src/ramifice/paladins/indexing.py</code> <pre><code>@classmethod\n@abstractmethod\nasync def indexing(cls) -&gt; None:\n    \"\"\"Set up and start indexing.\"\"\"\n</code></pre>"},{"location":"pages/paladins/password/","title":"Password","text":"<p>Verification, replacement and recoverang of password.</p>"},{"location":"pages/paladins/password/#ramifice.paladins.password.PasswordMixin","title":"<code>PasswordMixin</code>","text":"<p>Verification, replacement and recoverang of password.</p> Source code in <code>src/ramifice/paladins/password.py</code> <pre><code>class PasswordMixin:\n    \"\"\"Verification, replacement and recoverang of password.\"\"\"\n\n    async def verify_password(\n        self,\n        password: str,\n        field_name: str = \"password\",\n    ) -&gt; bool:\n        \"\"\"For password verification.\"\"\"\n        cls_model = self.__class__\n        # Get documet ID.\n        doc_id = self._id.value\n        if doc_id is None:\n            msg = (\n                f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n                + \"Method: `verify_password` =&gt; \"\n                + \"Cannot get document ID - ID field is empty.\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n        # Get collection for current Model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n        # Get document.\n        mongo_doc: dict[str, Any] | None = await collection.find_one({\"_id\": doc_id})\n        if mongo_doc is None:\n            msg = (\n                f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n                + \"Method: `verify_password` =&gt; \"\n                + f\"There is no document with ID `{self._id.value}` in the database.\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n        # Get password hash.\n        hash: str | None = mongo_doc.get(field_name)\n        if hash is None:\n            msg = (\n                f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n                + \"Method: `verify_password` =&gt; \"\n                + f\"The model does not have a field `{field_name}`.\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n        # Password verification.\n        is_valid: bool = False\n        ph = PasswordHasher()\n        with contextlib.suppress(BaseException):\n            is_valid = ph.verify(hash, password)\n        #\n        if is_valid and ph.check_needs_rehash(hash):\n            hash = ph.hash(password)\n            await collection.update_one({\"_id\": doc_id}, {\"$set\": {field_name: hash}})\n        #\n        return is_valid\n\n    async def update_password(\n        self,\n        old_password: str,\n        new_password: str,\n        field_name: str = \"password\",\n    ) -&gt; None:\n        \"\"\"For replace or recover password.\"\"\"\n        cls_model = self.__class__\n        if not await self.verify_password(old_password, field_name):\n            logger.warning(\"Old password does not match!\")\n            raise OldPassNotMatchError()\n        # Get documet ID.\n        doc_id = self._id.value\n        # Get collection for current Model.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n        # Create hash of new passwor.\n        ph = PasswordHasher()\n        hash: str = ph.hash(new_password)\n        await collection.update_one({\"_id\": doc_id}, {\"$set\": {field_name: hash}})\n</code></pre>"},{"location":"pages/paladins/password/#ramifice.paladins.password.PasswordMixin.update_password","title":"<code>update_password(old_password, new_password, field_name='password')</code>  <code>async</code>","text":"<p>For replace or recover password.</p> Source code in <code>src/ramifice/paladins/password.py</code> <pre><code>async def update_password(\n    self,\n    old_password: str,\n    new_password: str,\n    field_name: str = \"password\",\n) -&gt; None:\n    \"\"\"For replace or recover password.\"\"\"\n    cls_model = self.__class__\n    if not await self.verify_password(old_password, field_name):\n        logger.warning(\"Old password does not match!\")\n        raise OldPassNotMatchError()\n    # Get documet ID.\n    doc_id = self._id.value\n    # Get collection for current Model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n    # Create hash of new passwor.\n    ph = PasswordHasher()\n    hash: str = ph.hash(new_password)\n    await collection.update_one({\"_id\": doc_id}, {\"$set\": {field_name: hash}})\n</code></pre>"},{"location":"pages/paladins/password/#ramifice.paladins.password.PasswordMixin.verify_password","title":"<code>verify_password(password, field_name='password')</code>  <code>async</code>","text":"<p>For password verification.</p> Source code in <code>src/ramifice/paladins/password.py</code> <pre><code>async def verify_password(\n    self,\n    password: str,\n    field_name: str = \"password\",\n) -&gt; bool:\n    \"\"\"For password verification.\"\"\"\n    cls_model = self.__class__\n    # Get documet ID.\n    doc_id = self._id.value\n    if doc_id is None:\n        msg = (\n            f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n            + \"Method: `verify_password` =&gt; \"\n            + \"Cannot get document ID - ID field is empty.\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n    # Get collection for current Model.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n    # Get document.\n    mongo_doc: dict[str, Any] | None = await collection.find_one({\"_id\": doc_id})\n    if mongo_doc is None:\n        msg = (\n            f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n            + \"Method: `verify_password` =&gt; \"\n            + f\"There is no document with ID `{self._id.value}` in the database.\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n    # Get password hash.\n    hash: str | None = mongo_doc.get(field_name)\n    if hash is None:\n        msg = (\n            f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n            + \"Method: `verify_password` =&gt; \"\n            + f\"The model does not have a field `{field_name}`.\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n    # Password verification.\n    is_valid: bool = False\n    ph = PasswordHasher()\n    with contextlib.suppress(BaseException):\n        is_valid = ph.verify(hash, password)\n    #\n    if is_valid and ph.check_needs_rehash(hash):\n        hash = ph.hash(password)\n        await collection.update_one({\"_id\": doc_id}, {\"$set\": {field_name: hash}})\n    #\n    return is_valid\n</code></pre>"},{"location":"pages/paladins/refrash/","title":"Refrash","text":"<p>Update Model instance from database.</p>"},{"location":"pages/paladins/refrash/#ramifice.paladins.refrash.RefrashMixin","title":"<code>RefrashMixin</code>","text":"<p>Update Model instance from database.</p> Source code in <code>src/ramifice/paladins/refrash.py</code> <pre><code>class RefrashMixin:\n    \"\"\"Update Model instance from database.\"\"\"\n\n    async def refrash_from_db(self) -&gt; None:\n        \"\"\"Update Model instance from database.\"\"\"\n        cls_model = self.__class__\n        # Get collection.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n        mongo_doc: dict[str, Any] | None = await collection.find_one(filter={\"_id\": self._id.value})\n        if mongo_doc is None:\n            msg = (\n                f\"Model: `{self.full_model_name()}` &gt; \"\n                + \"Method: `refrash_from_db` =&gt; \"\n                + f\"A document with an identifier `{self._id.value}` is not exists in the database!\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n        self.inject()\n        refresh_from_mongo_doc(self, mongo_doc)\n</code></pre>"},{"location":"pages/paladins/refrash/#ramifice.paladins.refrash.RefrashMixin.refrash_from_db","title":"<code>refrash_from_db()</code>  <code>async</code>","text":"<p>Update Model instance from database.</p> Source code in <code>src/ramifice/paladins/refrash.py</code> <pre><code>async def refrash_from_db(self) -&gt; None:\n    \"\"\"Update Model instance from database.\"\"\"\n    cls_model = self.__class__\n    # Get collection.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n    mongo_doc: dict[str, Any] | None = await collection.find_one(filter={\"_id\": self._id.value})\n    if mongo_doc is None:\n        msg = (\n            f\"Model: `{self.full_model_name()}` &gt; \"\n            + \"Method: `refrash_from_db` =&gt; \"\n            + f\"A document with an identifier `{self._id.value}` is not exists in the database!\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n    self.inject()\n    refresh_from_mongo_doc(self, mongo_doc)\n</code></pre>"},{"location":"pages/paladins/save/","title":"Save","text":"<p>Create or update document in database.</p>"},{"location":"pages/paladins/save/#ramifice.paladins.save.SaveMixin","title":"<code>SaveMixin</code>","text":"<p>Create or update document in database.</p> Source code in <code>src/ramifice/paladins/save.py</code> <pre><code>class SaveMixin:\n    \"\"\"Create or update document in database.\"\"\"\n\n    async def save(self) -&gt; bool:\n        \"\"\"Create or update document in database.\n\n        This method pre-uses the `check` method.\n        \"\"\"\n        cls_model = self.__class__\n        # Get collection.\n        collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n        # Check Model.\n        result_check: dict[str, Any] = await self.check(is_save=True, collection=collection)\n        # Reset the alerts to exclude duplicates.\n        self._id.alerts = []\n        # Check the conditions and, if necessary, define a message for the web form.\n        if not result_check[\"is_update\"] and not cls_model.META[\"is_create_doc\"]:\n            self._id.alerts.append(\"It is forbidden to create new documents !\")\n            result_check[\"is_valid\"] = False\n        if result_check[\"is_update\"] and not cls_model.META[\"is_update_doc\"]:\n            self._id.alerts.append(\"It is forbidden to update documents !\")\n            result_check[\"is_valid\"] = False\n        # Leave the method if the check fails.\n        if not result_check[\"is_valid\"]:\n            ignored_fields_to_none(self)\n            return False\n        # Get data for document.\n        checked_data: dict[str, Any] = result_check[\"data\"]\n        # Create or update a document in database.\n        if result_check[\"is_update\"]:\n            # Update date and time.\n            checked_data[\"updated_at\"] = datetime.now(UTC_TIMEZONE)\n            # Run hook.\n            await self.pre_update()\n            # Update doc.\n            await collection.update_one({\"_id\": checked_data[\"_id\"]}, {\"$set\": checked_data})\n            # Run hook.\n            await self.post_update()\n            # Refresh Model.\n            mongo_doc: dict[str, Any] | None = await collection.find_one({\"_id\": checked_data[\"_id\"]})\n            if mongo_doc is None:\n                msg = (\n                    f\"Model: `{self.full_model_name()}` &gt; \"\n                    + \"Method: `save` =&gt; \"\n                    + \"Geted value is None - it is impossible to refresh the current Model.\"\n                )\n                logger.critical(msg)\n                raise PanicError(msg)\n            refresh_from_mongo_doc(self, mongo_doc)\n        else:\n            # Add date and time.\n            today = datetime.now(UTC_TIMEZONE)\n            checked_data[\"created_at\"] = today\n            checked_data[\"updated_at\"] = today\n            # Run hook.\n            await self.pre_create()\n            # Insert doc.\n            await collection.insert_one(checked_data)\n            # Run hook.\n            await self.post_create()\n            # Refresh Model.\n            mongo_doc = await collection.find_one({\"_id\": checked_data[\"_id\"]})\n            if mongo_doc is None:\n                msg = f\"Model: `{self.full_model_name()}` &gt; \" + \"Method: `save` =&gt; \" + \"The document was not created.\"\n                logger.critical(msg)\n                raise PanicError(msg)\n            refresh_from_mongo_doc(self, mongo_doc)\n        #\n        # If everything is completed successfully.\n        return True\n</code></pre>"},{"location":"pages/paladins/save/#ramifice.paladins.save.SaveMixin.save","title":"<code>save()</code>  <code>async</code>","text":"<p>Create or update document in database.</p> <p>This method pre-uses the <code>check</code> method.</p> Source code in <code>src/ramifice/paladins/save.py</code> <pre><code>async def save(self) -&gt; bool:\n    \"\"\"Create or update document in database.\n\n    This method pre-uses the `check` method.\n    \"\"\"\n    cls_model = self.__class__\n    # Get collection.\n    collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n    # Check Model.\n    result_check: dict[str, Any] = await self.check(is_save=True, collection=collection)\n    # Reset the alerts to exclude duplicates.\n    self._id.alerts = []\n    # Check the conditions and, if necessary, define a message for the web form.\n    if not result_check[\"is_update\"] and not cls_model.META[\"is_create_doc\"]:\n        self._id.alerts.append(\"It is forbidden to create new documents !\")\n        result_check[\"is_valid\"] = False\n    if result_check[\"is_update\"] and not cls_model.META[\"is_update_doc\"]:\n        self._id.alerts.append(\"It is forbidden to update documents !\")\n        result_check[\"is_valid\"] = False\n    # Leave the method if the check fails.\n    if not result_check[\"is_valid\"]:\n        ignored_fields_to_none(self)\n        return False\n    # Get data for document.\n    checked_data: dict[str, Any] = result_check[\"data\"]\n    # Create or update a document in database.\n    if result_check[\"is_update\"]:\n        # Update date and time.\n        checked_data[\"updated_at\"] = datetime.now(UTC_TIMEZONE)\n        # Run hook.\n        await self.pre_update()\n        # Update doc.\n        await collection.update_one({\"_id\": checked_data[\"_id\"]}, {\"$set\": checked_data})\n        # Run hook.\n        await self.post_update()\n        # Refresh Model.\n        mongo_doc: dict[str, Any] | None = await collection.find_one({\"_id\": checked_data[\"_id\"]})\n        if mongo_doc is None:\n            msg = (\n                f\"Model: `{self.full_model_name()}` &gt; \"\n                + \"Method: `save` =&gt; \"\n                + \"Geted value is None - it is impossible to refresh the current Model.\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n        refresh_from_mongo_doc(self, mongo_doc)\n    else:\n        # Add date and time.\n        today = datetime.now(UTC_TIMEZONE)\n        checked_data[\"created_at\"] = today\n        checked_data[\"updated_at\"] = today\n        # Run hook.\n        await self.pre_create()\n        # Insert doc.\n        await collection.insert_one(checked_data)\n        # Run hook.\n        await self.post_create()\n        # Refresh Model.\n        mongo_doc = await collection.find_one({\"_id\": checked_data[\"_id\"]})\n        if mongo_doc is None:\n            msg = f\"Model: `{self.full_model_name()}` &gt; \" + \"Method: `save` =&gt; \" + \"The document was not created.\"\n            logger.critical(msg)\n            raise PanicError(msg)\n        refresh_from_mongo_doc(self, mongo_doc)\n    #\n    # If everything is completed successfully.\n    return True\n</code></pre>"},{"location":"pages/paladins/tools/","title":"Tools","text":"<p>Tool of Paladins - A set of auxiliary methods.</p>"},{"location":"pages/paladins/tools/#ramifice.paladins.tools.accumulate_error","title":"<code>accumulate_error(err_msg, params)</code>","text":"<p>Accumulating errors to ModelName.field_name.errors .</p> Source code in <code>src/ramifice/paladins/tools.py</code> <pre><code>def accumulate_error(err_msg: str, params: dict[str, Any]) -&gt; None:\n    \"\"\"Accumulating errors to ModelName.field_name.errors .\"\"\"\n    if not params[\"field_data\"].hide:\n        params[\"field_data\"].errors.append(err_msg)\n        if not params[\"is_error_symptom\"]:\n            params[\"is_error_symptom\"] = True\n    else:\n        msg = (\n            f\"&gt;&gt;hidden field&lt;&lt; -&gt; Model: `{params['full_model_name']}` &gt; \"\n            + f\"Field: `{params['field_data'].name}`\"\n            + f\" =&gt; {err_msg}\"\n        )\n        logger.critical(msg)\n        raise errors.PanicError(msg)\n</code></pre>"},{"location":"pages/paladins/tools/#ramifice.paladins.tools.check_uniqueness","title":"<code>check_uniqueness(value, params, field_name=None, is_multi_language=False)</code>  <code>async</code>","text":"<p>Checking the uniqueness of the value in the collection.</p> Source code in <code>src/ramifice/paladins/tools.py</code> <pre><code>async def check_uniqueness(\n    value: str | int | float,\n    params: dict[str, Any],\n    field_name: str | None = None,\n    is_multi_language: bool = False,\n) -&gt; bool:\n    \"\"\"Checking the uniqueness of the value in the collection.\"\"\"\n    q_filter = None\n    if is_multi_language:\n        lang_filter = [{f\"{field_name}.{lang}\": value} for lang in translations.LANGUAGES]\n        q_filter = {\n            \"$and\": [\n                {\"_id\": {\"$ne\": params[\"doc_id\"]}},\n                {\"$or\": lang_filter},\n            ],\n        }\n    else:\n        q_filter = {\n            \"$and\": [\n                {\"_id\": {\"$ne\": params[\"doc_id\"]}},\n                {field_name: value},\n            ],\n        }\n    return await params[\"collection\"].find_one(q_filter) is None\n</code></pre>"},{"location":"pages/paladins/tools/#ramifice.paladins.tools.ignored_fields_to_none","title":"<code>ignored_fields_to_none(inst_model)</code>","text":"<p>Reset the values of ignored fields to None.</p> Source code in <code>src/ramifice/paladins/tools.py</code> <pre><code>def ignored_fields_to_none(inst_model: Any) -&gt; None:\n    \"\"\"Reset the values of ignored fields to None.\"\"\"\n    for _, field_data in inst_model.__dict__.items():\n        if not callable(field_data) and field_data.ignored:\n            field_data.value = None\n</code></pre>"},{"location":"pages/paladins/tools/#ramifice.paladins.tools.panic_type_error","title":"<code>panic_type_error(value_type, params)</code>","text":"<p>Unacceptable type of value.</p> Source code in <code>src/ramifice/paladins/tools.py</code> <pre><code>def panic_type_error(value_type: str, params: dict[str, Any]) -&gt; None:\n    \"\"\"Unacceptable type of value.\"\"\"\n    msg = (\n        f\"Model: `{params['full_model_name']}` &gt; \"\n        + f\"Field: `{params['field_data'].name}` &gt; \"\n        + f\"Parameter: `value` =&gt; Must be `{value_type}` type!\"\n    )\n    logger.critical(msg)\n    raise errors.PanicError(msg)\n</code></pre>"},{"location":"pages/paladins/tools/#ramifice.paladins.tools.refresh_from_mongo_doc","title":"<code>refresh_from_mongo_doc(inst_model, mongo_doc)</code>","text":"<p>Update object instance from Mongo document.</p> Source code in <code>src/ramifice/paladins/tools.py</code> <pre><code>def refresh_from_mongo_doc(inst_model: Any, mongo_doc: dict[str, Any]) -&gt; None:\n    \"\"\"Update object instance from Mongo document.\"\"\"\n    lang: str = translations.CURRENT_LOCALE\n    model_dict = inst_model.__dict__\n    for name, data in mongo_doc.items():\n        field = model_dict[name]\n        if field.field_type == \"TextField\" and field.multi_language:\n            field.value = data.get(lang, \"- -\") if data is not None else None\n        elif field.group == \"pass\":\n            field.value = None\n        else:\n            field.value = data\n</code></pre>"},{"location":"pages/paladins/validation/","title":"Validation","text":"<p>Validation of Model and printing errors to console.</p>"},{"location":"pages/paladins/validation/#ramifice.paladins.validation.ValidationMixin","title":"<code>ValidationMixin</code>","text":"<p>Validation of Model and printing errors to console.</p> Source code in <code>src/ramifice/paladins/validation.py</code> <pre><code>class ValidationMixin:\n    \"\"\"Validation of Model and printing errors to console.\"\"\"\n\n    async def is_valid(self) -&gt; bool:\n        \"\"\"Check data validity.\n\n        The main use is to check data from web forms.\n        It is also used to verify Models that do not migrate to the database.\n        \"\"\"\n        result_check: dict[str, Any] = await self.check()\n        return result_check[\"is_valid\"]\n\n    def print_err(self) -&gt; None:\n        \"\"\"Printing errors to console.\n\n        Convenient to use during development.\n        \"\"\"\n        is_err: bool = False\n        for field_name, field_data in self.__dict__.items():\n            if callable(field_data):\n                continue\n            if len(field_data.errors) &gt; 0:\n                # title\n                if not is_err:\n                    print(colored(\"\\nERRORS:\", \"red\", attrs=[\"bold\"]))  # noqa: T201\n                    print(colored(\"Model: \", \"blue\", attrs=[\"bold\"]), end=\"\")  # noqa: T201\n                    print(colored(f\"`{self.full_model_name()}`\", \"blue\"))  # noqa: T201\n                    is_err = True\n                # field name\n                print(colored(\"Field: \", \"green\", attrs=[\"bold\"]), end=\"\")  # noqa: T201\n                print(colored(f\"`{field_name}`:\", \"green\"))  # noqa: T201\n                # error messages\n                print(colored(\"\\n\".join(field_data.errors), \"red\"))  # noqa: T201\n        if len(self._id.alerts) &gt; 0:\n            # title\n            print(colored(\"AlERTS:\", \"yellow\", attrs=[\"bold\"]))  # noqa: T201\n            # messages\n            print(colored(\"\\n\".join(self._id.alerts), \"yellow\"), end=\"\\n\\n\")  # noqa: T201\n        else:\n            print(end=\"\\n\\n\")  # noqa: T201\n</code></pre>"},{"location":"pages/paladins/validation/#ramifice.paladins.validation.ValidationMixin.is_valid","title":"<code>is_valid()</code>  <code>async</code>","text":"<p>Check data validity.</p> <p>The main use is to check data from web forms. It is also used to verify Models that do not migrate to the database.</p> Source code in <code>src/ramifice/paladins/validation.py</code> <pre><code>async def is_valid(self) -&gt; bool:\n    \"\"\"Check data validity.\n\n    The main use is to check data from web forms.\n    It is also used to verify Models that do not migrate to the database.\n    \"\"\"\n    result_check: dict[str, Any] = await self.check()\n    return result_check[\"is_valid\"]\n</code></pre>"},{"location":"pages/paladins/validation/#ramifice.paladins.validation.ValidationMixin.print_err","title":"<code>print_err()</code>","text":"<p>Printing errors to console.</p> <p>Convenient to use during development.</p> Source code in <code>src/ramifice/paladins/validation.py</code> <pre><code>def print_err(self) -&gt; None:\n    \"\"\"Printing errors to console.\n\n    Convenient to use during development.\n    \"\"\"\n    is_err: bool = False\n    for field_name, field_data in self.__dict__.items():\n        if callable(field_data):\n            continue\n        if len(field_data.errors) &gt; 0:\n            # title\n            if not is_err:\n                print(colored(\"\\nERRORS:\", \"red\", attrs=[\"bold\"]))  # noqa: T201\n                print(colored(\"Model: \", \"blue\", attrs=[\"bold\"]), end=\"\")  # noqa: T201\n                print(colored(f\"`{self.full_model_name()}`\", \"blue\"))  # noqa: T201\n                is_err = True\n            # field name\n            print(colored(\"Field: \", \"green\", attrs=[\"bold\"]), end=\"\")  # noqa: T201\n            print(colored(f\"`{field_name}`:\", \"green\"))  # noqa: T201\n            # error messages\n            print(colored(\"\\n\".join(field_data.errors), \"red\"))  # noqa: T201\n    if len(self._id.alerts) &gt; 0:\n        # title\n        print(colored(\"AlERTS:\", \"yellow\", attrs=[\"bold\"]))  # noqa: T201\n        # messages\n        print(colored(\"\\n\".join(self._id.alerts), \"yellow\"), end=\"\\n\\n\")  # noqa: T201\n    else:\n        print(end=\"\\n\\n\")  # noqa: T201\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":"<p>Examples of use.</p> <p>It is recommended to look at examples here.</p>"},{"location":"pages/usage/class_methods/","title":"Class Methods","text":"<p>Examples of frequently used methods:</p> main.py<pre><code># Gets an estimate of the count of documents in a collection using collection metadata.\ncount: int = await User.estimated_document_count()\n\n# Gets an estimate of the count of documents in a collection using collection metadata.\nq_filter = {\"first_name\": \"John\"}\ncount: int = await User.count_documents(q_filter)\n\n# Runs an aggregation framework pipeline.\nfrom bson.bson import BSON\npipeline = [\n    {\"$unwind\": \"$tags\"},\n    {\"$group\": {\"_id\": \"$tags\", \"count\": {\"$sum\": 1}}},\n    {\"$sort\": BSON([(\"count\", -1), (\"_id\", -1)])},\n]\ndocs = await User.aggregate(pipeline)\n\n# Finds the distinct values for a specified field across a single collection.\nq_filter = \"key_name\"\nvalues = await User.distinct(q_filter)\n\n# Get collection name.\nname = await User.collection_name()\n\n# The full name is of the form database_name.collection_name.\nname = await User.collection_full_name()\n\n# Get AsyncBatabase for the current Model.\ndatabase = await User.database()\n\n# Get AsyncCollection for the current Model.\ncollection = await User.collection()\n\n# Find a single document.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\nmongo_doc = await User.find_one(q_filter)\n\n# Create object instance from Mongo document.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\nmongo_doc = await User.find_one(q_filter)\nuser = User.from_mongo_doc(mongo_doc)\n\n# Find a single document and converting to raw document.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\nraw_doc = await User.find_one_to_raw_doc(q_filter)\n\n# Find a single document and convert it to a Model instance.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\nuser = await User.find_one_to_instance(q_filter)\n\n# Find a single document and convert it to a JSON string.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\njson = await User.find_one_to_json(q_filter)\n\n# Find a single document and delete it.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\ndelete_result = await User.delete_one(q_filter)\n\n# Find a single document and delete it, return original.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\nmongo_doc = await User.find_one_and_delete(q_filter)\n\n# Find documents.\nq_filter = {\"first_name\": \"John\"}\nmongo_docs = await User.find_many(q_filter)\n\n# Find documents and convert to a raw documents.\nq_filter = {\"first_name\": \"John\"}\nraw_docs = await User.find_many_to_raw_docs(q_filter)\n\n# Find documents and convert to a json string.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\njson = await User.find_many_to_json(q_filter)\n\n# Find documents matching with Model.\nq_filter = {\"email\": \"John_Smith@gmail.com\"}\ndelete_result = await User.delete_many(q_filter)\n\n# Creates an index on this collection.\nfrom pymongo import ASCENDING\nkeys = [(\"email\", ASCENDING)]\nresult: str = await User.create_index(keys, name=\"idx_email\")\n\n# Drops the specified index on this collection.\nUser.drop_index(\"idx_email\")\n\n# Create one or more indexes on this collection.\nfrom pymongo import ASCENDING, DESCENDING\nindex_1 = IndexModel([(\"username\", DESCENDING), (\"email\", ASCENDING)], name=\"idx_username_email\")\nindex_2 = IndexModel([(\"first_name\", DESCENDING)], name=\"idx_first_name\")\nresult: list[str] = await User.create_indexes([index_1, index_2])\n\n# Drops all indexes on this collection.\nUser.drop_index()\n\n# Get information on this collection\u2019s indexes.\nresult = await User.index_information()\n\n# Get a cursor over the index documents for this collection.\nasync for index in await User.list_indexes():\n    print(index)\n\n# Units Management.\n# Management for `choices` parameter in dynamic field types.\n# Units are stored in a separate collection.\nfrom ramifice import Unit\nunit = Unit(\n  field=\"field_name\",  # The name of the dynamic field.\n  title={\"en\": \"Title\", \"ru\": \"\u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a\"},  # The name of the choice item.\n  value=\"Some text ...\",  # The value of the choice item.\n                          # Hint: float | int | str\n  is_delete=False, # True - if you need to remove the item of choice.\n                   # by default = False (add item to choice)\n)\nawait User.unit_manager(unit)\n</code></pre>"},{"location":"pages/usage/create_model/","title":"Create Model","text":"<p>It is recommended to look at examples here.</p> main.py<pre><code>import re\nimport asyncio\nfrom typing import Any\nfrom datetime import datetime\nfrom pprint import pprint as pp\n\nfrom pymongo import AsyncMongoClient\nfrom ramifice import (\n    NamedTuple,\n    model,\n    translations,\n    Migration,\n    to_human_size,\n)\nfrom ramifice.fields import (\n    ImageField,\n    PasswordField,\n    TextField,\n)\n\n\n@model(service_name=\"Accounts\")\nclass User:\n    \"\"\"Model of User.\"\"\"\n\n    def fields(self) -&gt; None:\n        \"\"\"Adding fields.\"\"\"\n        # For custom translations.\n        gettext = translations.gettext\n        # ngettext = translations.ngettext\n        self.avatar = ImageField(\n            label=gettext(\"Avatar\"),\n            default=\"public/media/default/no-photo.png\",\n            # Directory for images inside media directory.\n            target_dir=\"users/avatars\",\n            # Available 4 sizes from lg to xs or None.\n            # Hint: By default = None\n            thumbnails={\"lg\": 512, \"md\": 256, \"sm\": 128, \"xs\": 64},\n            # The maximum size of the original image in bytes.\n            # Hint: By default = 2 MB\n            max_size=524288,  # 0.5 MB = 512 KB = 524288 Bytes (in binary)\n            warning=[\n                gettext(\"Maximum size: {}\").format(to_human_size(524288)),\n            ],\n        )\n        self.username = TextField(\n            label=gettext(\"Username\"),\n            maxlength=150,\n            required=True,\n            unique=True,\n            warning=[\n                gettext(\"Allowed chars: {}\").format(\"a-z A-Z 0-9 _\"),\n            ],\n        )\n        self.password = PasswordField(\n            label=gettext(\"Password\"),\n        )\n        self.\u0441onfirm_password = PasswordField(\n            label=gettext(\"Confirm password\"),\n            # If true, the value of this field is not saved in the database.\n            ignored=True,\n        )\n\n    # Optional method\n    async def add_validation(self) -&gt; NamedTuple:\n        \"\"\"Additional validation of fields.\"\"\"\n        gettext = translations.gettext\n        cd, err = self.get_clean_data()\n\n        # Check username\n        if re.match(r\"^[a-zA-Z0-9_]+$\", cd.username) is None:\n            err.update(\"username\", gettext(\"Allowed chars: {}\").format(\"a-z A-Z 0-9 _\"))\n\n        # Check password\n        if cd._id is None and (cd.password != cd.\u0441onfirm_password):\n            err.update(\"password\", gettext(\"Passwords do not match!\"))\n\n        return err\n\n\nasync def main():\n    client = AsyncMongoClient()\n\n    await Migration(\n        database_name=\"test_db\",\n        mongo_client=client,\n    ).migrate()\n\n    # If you need to change the language of translation.\n    # Hint: For Ramifice by default = \"en\"\n    translations.change_locale(\"en\")\n\n    user = User()\n    # user.avatar.from_path(\"public/media/default/no-photo.png\")\n    user.username.value = \"pythondev\"\n    user.password.value = \"12345678\"\n    user.\u0441onfirm_password.value = \"12345678\"\n\n    # Create User.\n    if not await user.save():\n        # Convenient to use during development.\n        user.print_err()\n\n    # Update User.\n    user.username.value = \"pythondev_123\"\n    if not await user.save():\n        user.print_err()\n\n    print(\"User details:\")\n    user_details = await User.find_one_to_raw_doc(\n        # {\"_id\": user.id.value}\n        {f\"username\": user.username.value}\n    )\n    if user_details is not None:\n        pp(user_details)\n    else:\n        print(\"No User!\")\n\n    # Remove User.\n    # (if necessary)\n    # await user.delete()\n    # await user.delete(remove_files=False)\n\n    # Remove collection.\n    # (if necessary)\n    # await User.collection().drop()\n\n    # Close connection.\n    await client.close()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"pages/usage/instance_methods/","title":"Instance Methods","text":"<p>Examples of frequently used methods:</p> main.py<pre><code># Check data validity.\n# The main use is to check data from web forms.\n# It is also used to verify Models that do not migrate to the database.\nuser = User()\nif not await user.is_valid():\n    user.print_err()  # Convenient to use during development.\n\n# Create or update document in database.\n# This method pre-uses the `check` method.\nuser = User()\nif not await user.save():\n    user.print_err()  # Convenient to use during development.\n\n# Delete document from database.\nuser = User()\nawait user.delete()\n# or\nawait user.delete(remove_files=False)\n\n# Verification, replacement and recoverang of password.\nuser = User()\nawait user.verify_password(password=\"12345678\")\nawait user.update_password(  # + verify_password\n  old_password=\"12345678\",\n  new_password=\"O2eA4GIr38KGGlS\",\n)\n</code></pre>"},{"location":"pages/usage/model_parameters/","title":"Model Parameters","text":"<p>Only <code>service_name</code> is a required parameter.</p> Parameter Default Description service_name no Examples: Accounts | Smartphones | Washing machines | etc ...  fixture_name None           The name of the fixture in the config/fixtures directory (without extension).           Examples: SiteSettings | AppSettings | etc ...         db_query_docs_limit 1000 Limiting the number of request results. is_create_doc True           Can a Model create new documents in a collection?          Set to False if you only need one document in the collection and the Model is using a fixture.         is_update_doc True Can a Model update documents in a collection? is_delete_doc True Can a Model remove documents from a collection?"},{"location":"pages/usage/model_parameters/#example","title":"Example","text":"main.py<pre><code>@model(\n    service_name=\"ServiceName\",\n    fixture_name=\"FixtureName\",\n    db_query_docs_limit=1000,\n    is_create_doc = True,\n    is_update_doc = True,\n    is_delete_doc = True,\n)\nclass User:\n    def fields(self):\n        self.username = TextField(\n            label=gettext(\"Username\"),\n            required=True,\n            unique=True,\n        )\n</code></pre>"},{"location":"pages/usage/utils/","title":"Utils","text":"<p>General auxiliary methods:</p> <pre><code>from xloft.converters import to_human_size\nfrom xloft.itis import is_number\nfrom ramifice.utils.tools import (\n    get_file_size,\n    hash_to_obj_id,\n    is_color,\n    is_email,\n    is_ip,\n    is_mongo_id,\n    is_password,\n    is_phone,\n    is_url,\n    normal_email,\n)\n\n\n# Convert the number of bytes into a human-readable format.\nsize: str = to_human_size(2097152)\nprint(size)  # =&gt; 2 MB\n\n# Check if a string is a number.\nif is_number(\"5\"):\n    ...\n\n# Validate Password.\nif is_password(\"12345678\"):\n    ...\n\n# Validate Email address.\nif await is_email(\"kebasyaty@gmail.com\"):\n    ...\n\n# Normalizing email address.\n# Use this before requeste to a database.\n# For example, on the login page.\nemail: str | None = normal_email(\"kebasyaty@gmail.com\")  # None, if not valid\n\n# Validate URL address.\nif is_url(\"https://www.google.com\"):\n    ...\n\n# Validate IP address.\nif is_ip(\"127.0.0.1\"):\n    ...\n\n# Validate Color code.\nif is_color(\"#000\"):\n    ...\n\n# Validate Phone number.\nif is_phone(\"+447986123456\"):\n    ...\n\n# Validation of the Mongodb identifier.\nif is_mongo_id(\"666f6f2d6261722d71757578\"):\n    ...\n\n# Get ObjectId from hash string.\nfrom bson.objectid import ObjectId\n_id: ObjectId | None = hash_to_obj_id(\"666f6f2d6261722d71757578\")\n\n# Get file size in bytes.\npath = \"public/media/default/no_doc.odt\"\nsize: int = get_file_size(path)\nprint(size)  # =&gt; 9843\n</code></pre>"},{"location":"pages/utils/","title":"Utils","text":"<p>A set of Ramifice useful utilities.</p> <p>This module includes:</p> <ul> <li><code>constants</code> - Global variables.</li> <li><code>errors</code> - Custom Exceptions for Ramifice.</li> <li><code>fixtures</code> - To populate the database with pre-created data.</li> <li><code>migration</code> - Migration of models to database.</li> <li><code>mixins</code> - Set of mixins for Models and Fields.</li> <li><code>tools</code> - Global collection of auxiliary methods.</li> <li><code>translations</code> - Localization of translations.</li> <li><code>unit</code> - Data management in dynamic fields.</li> </ul>"},{"location":"pages/utils/constants/","title":"Constants","text":"<p>Global variables.</p> <p>List of variables:</p> <ul> <li><code>DEBUG</code> - Caching a condition for the verification code.</li> <li><code>MONGO_CLIENT</code> - Caching a Mongo client.</li> <li><code>MONGO_DATABASE</code> - Caching a Mongo database.</li> <li><code>DATABASE_NAME</code> - Caching a database name.</li> <li><code>SUPER_COLLECTION_NAME</code> - Caching a super collection name.</li> <li><code>MEDIA_ROOT</code> - Absolute filesystem path to the directory that will hold user-uploaded files.</li> <li><code>MEDIA_URL</code> - URL that handles the media served from MEDIA_ROOT, used for managing stored files.</li> <li><code>STATIC_ROOT</code> - The absolute path to the directory where static files are located.</li> <li><code>STATIC_URL</code> - URL to use when referring to static files located in STATIC_ROOT.</li> <li><code>UTC_TIMEZONE</code> - Caching a patterns of regular expression.</li> <li><code>REGEX</code> - Caching a patterns of regular expression.</li> </ul>"},{"location":"pages/utils/errors/","title":"Errors","text":"<p>Custom Exceptions for Ramifice.</p>"},{"location":"pages/utils/errors/#ramifice.utils.errors.DoesNotMatchRegexError","title":"<code>DoesNotMatchRegexError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception raised if does not match the regular expression.</p> <p>Parameters:</p> Name Type Description Default <code>regex_str</code> <code>str</code> <p>regular expression in string representation</p> required Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class DoesNotMatchRegexError(RamificeException):\n    \"\"\"Exception raised if does not match the regular expression.\n\n    Args:\n        regex_str: regular expression in string representation\n    \"\"\"\n\n    def __init__(self, regex_str: str) -&gt; None:  # noqa: D107\n        self.message = f\"Does not match the regular expression: {regex_str}\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.FileHasNoExtensionError","title":"<code>FileHasNoExtensionError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception raised if the file has no extension.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>explanation of the error</p> <code>'File has no extension!'</code> Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class FileHasNoExtensionError(RamificeException):\n    \"\"\"Exception raised if the file has no extension.\n\n    Args:\n        message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message: str = \"File has no extension!\") -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.ForbiddenDeleteDocError","title":"<code>ForbiddenDeleteDocError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception is raised when trying to delete the document.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>explanation of the error</p> required Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class ForbiddenDeleteDocError(RamificeException):\n    \"\"\"Exception is raised when trying to delete the document.\n\n    Args:\n        message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message: str) -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.NoModelsForMigrationError","title":"<code>NoModelsForMigrationError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception raised if no Models for migration.</p> Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class NoModelsForMigrationError(RamificeException):\n    \"\"\"Exception raised if no Models for migration.\"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.message = \"No Models for Migration!\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.NotPossibleAddUnitError","title":"<code>NotPossibleAddUnitError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception is raised when not possible to add Unit.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>explanation of the error</p> required Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class NotPossibleAddUnitError(RamificeException):\n    \"\"\"Exception is raised when not possible to add Unit.\n\n    Args:\n        message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message: str) -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.NotPossibleDeleteUnitError","title":"<code>NotPossibleDeleteUnitError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception is raised when not possible to delete Unit.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>explanation of the error</p> required Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class NotPossibleDeleteUnitError(RamificeException):\n    \"\"\"Exception is raised when not possible to delete Unit.\n\n    Args:\n        message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message: str) -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.OldPassNotMatchError","title":"<code>OldPassNotMatchError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception is raised when trying to update the password.</p> <p>Hint: If old password does not match.</p> Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class OldPassNotMatchError(RamificeException):\n    \"\"\"Exception is raised when trying to update the password.\n\n    Hint: If old password does not match.\n    \"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.message = \"Old password does not match!\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.PanicError","title":"<code>PanicError</code>","text":"<p>               Bases: <code>RamificeException</code></p> <p>Exception raised for cases of which should not be.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>explanation of the error</p> required Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class PanicError(RamificeException):\n    \"\"\"Exception raised for cases of which should not be.\n\n    Args:\n        message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message: str) -&gt; None:  # noqa: D107\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"pages/utils/errors/#ramifice.utils.errors.RamificeException","title":"<code>RamificeException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root Exception for Ramifice.</p> Source code in <code>src/ramifice/utils/errors.py</code> <pre><code>class RamificeException(Exception):\n    \"\"\"Root Exception for Ramifice.\"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:  # type: ignore[no-untyped-def] # noqa: D107\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"pages/utils/fixtures/","title":"Fixtures","text":"<p>Fixtures - To populate the database with pre-created data.</p> <p>Runs automatically during Model migration.</p>"},{"location":"pages/utils/fixtures/#ramifice.utils.fixtures.apply_fixture","title":"<code>apply_fixture(fixture_name, cls_model, collection)</code>  <code>async</code>","text":"<p>Apply fixture for current Model.</p> <p>Runs automatically during Model migration.</p> Source code in <code>src/ramifice/utils/fixtures.py</code> <pre><code>async def apply_fixture(\n    fixture_name: str,\n    cls_model: Any,\n    collection: AsyncCollection,\n) -&gt; None:\n    \"\"\"Apply fixture for current Model.\n\n    Runs automatically during Model migration.\n    \"\"\"\n    fixture_path: str = f\"config/fixtures/{fixture_name}.yml\"\n    data_yaml: dict[str, Any] | list[dict[str, Any]] | None = None\n\n    with Path.open(Path(fixture_path)) as file:\n        data_yaml = yaml.safe_load(file)\n\n    if not bool(data_yaml):\n        msg = (\n            f\"Model: `{cls_model.META['full_model_name']}` &gt; \"\n            + f\"META param: `fixture_name` ({fixture_name}) =&gt; \"\n            + \"It seems that fixture is empty or it has incorrect contents!\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n\n    if data_yaml is not None:\n        if not isinstance(data_yaml, list):\n            data_yaml = [data_yaml]\n\n        for data in data_yaml:\n            inst_model = cls_model()\n            for field_name, field_data in inst_model.__dict__.items():\n                if callable(field_data) or field_data.ignored:\n                    continue\n                group = field_data.group\n                value: Any | None = data.get(field_name)\n                if value == \"None\":\n                    value = None\n                if value is not None:\n                    if group == \"file\" or group == \"img\":\n                        await field_data.from_path(value)\n                    elif group == \"date\":\n                        field_data.value = parse(value)\n                    else:\n                        field_data.value = value\n            # Check Model.\n            result_check: dict[str, Any] = await inst_model.check(\n                is_save=True,\n                collection=collection,\n            )\n            # If the check fails.\n            if not result_check[\"is_valid\"]:\n                await collection.database.drop_collection(collection.name)\n                print(colored(\"\\nFIXTURE:\", \"red\", attrs=[\"bold\"]))  # noqa: T201\n                print(colored(fixture_path, \"blue\", attrs=[\"bold\"]))  # noqa: T201\n                inst_model.print_err()\n                msg = f\"Fixture `{fixture_name}` failed.\"\n                logger.critical(msg)\n                raise PanicError(msg)\n            # Get data for document.\n            checked_data: dict[str, Any] = result_check[\"data\"]\n            # Add date and time.\n            today = datetime.now(UTC_TIMEZONE)\n            checked_data[\"created_at\"] = today\n            checked_data[\"updated_at\"] = today\n            # Run hook.\n            await inst_model.pre_create()\n            # Insert doc.\n            try:\n                await collection.insert_one(checked_data)\n            except:\n                await collection.database.drop_collection(collection.name)\n            # Run hook.\n            await inst_model.post_create()\n</code></pre>"},{"location":"pages/utils/migration/","title":"Migration","text":"<p>Migration are <code>Ramifice</code> way of propagating changes you make to your models (add or delete a Model, add or delete a field in Model, etc.) into your database schema.</p>"},{"location":"pages/utils/migration/#ramifice.utils.migration.Migration","title":"<code>Migration</code>","text":"<p>Migration of models to database.</p> Source code in <code>src/ramifice/utils/migration.py</code> <pre><code>class Migration:\n    \"\"\"Migration of models to database.\"\"\"\n\n    def __init__(self, database_name: str, mongo_client: AsyncMongoClient) -&gt; None:  # noqa: D107\n        constants.DEBUG = False\n        #\n        db_name_regex = constants.REGEX[\"database_name\"]\n        if db_name_regex.match(database_name) is None:\n            regex_str: str = \"^[a-zA-Z][-_a-zA-Z0-9]{0,59}$\"\n            msg: str = f\"Does not match the regular expression: {regex_str}\"\n            logger.critical(msg)\n            raise DoesNotMatchRegexError(regex_str)\n        #\n        constants.DATABASE_NAME = database_name\n        constants.MONGO_CLIENT = mongo_client\n        constants.MONGO_DATABASE = constants.MONGO_CLIENT[constants.DATABASE_NAME]\n        # Get Model list.\n        self.model_list: list[Any] = Model.__subclasses__()\n        # Raise the exception if there are no models for migration.\n        if len(self.model_list) == 0:\n            logger.critical(\"No Models for Migration!\")\n            raise NoModelsForMigrationError()\n\n    async def reset(self) -&gt; None:\n        \"\"\"Reset the condition of the models in a super collection.\n\n        Switch the `is_model_exist` parameter in the condition `False`.\n        \"\"\"\n        # Get access to super collection.\n        # (Contains Model state and dynamic field data.)\n        super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n        # Switch the `is_model_exist` parameter in `False`.\n        async for model_state in super_collection.find():\n            q_filter = {\"collection_name\": model_state[\"collection_name\"]}\n            update = {\"$set\": {\"is_model_exist\": False}}\n            await super_collection.update_one(q_filter, update)\n\n    async def model_state(self, metadata: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Get the state of the current model from a super collection.\"\"\"\n        # Get access to super collection.\n        # (Contains Model state and dynamic field data.)\n        super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n        # Get state of current Model.\n        model_state: dict[str, Any] | None = await super_collection.find_one(\n            {\"collection_name\": metadata[\"collection_name\"]},\n        )\n        if model_state is not None:\n            model_state[\"is_model_exist\"] = True\n        else:\n            # Create a state for new Model.\n            model_state = {\n                \"collection_name\": metadata[\"collection_name\"],\n                \"field_name_and_type\": metadata[\"field_name_and_type\"],\n                \"data_dynamic_fields\": metadata[\"data_dynamic_fields\"],\n                \"is_model_exist\": True,\n            }\n            await super_collection.insert_one(model_state)\n        return model_state\n\n    def new_fields(self, metadata: dict[str, Any], model_state: dict[str, Any]) -&gt; list[str]:\n        \"\"\"Get a list of new fields that were added to Model.\"\"\"\n        new_fields: list[str] = []\n        for field_name, field_type in metadata[\"field_name_and_type\"].items():\n            old_field_type: str | None = model_state[\"field_name_and_type\"].get(field_name)\n            if old_field_type is None or old_field_type != field_type:\n                new_fields.append(field_name)\n        return new_fields\n\n    async def napalm(self) -&gt; None:\n        \"\"\"Delete data for non-existent Models from a super collection,\n        delete collections associated with those Models.\n        \"\"\"  # noqa: D205\n        # Get access to database.\n        database = constants.MONGO_DATABASE\n        # Get access to super collection.\n        # (Contains Model state and dynamic field data.)\n        super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n        # Delete data for non-existent Models.\n        async for model_state in super_collection.find():\n            if model_state[\"is_model_exist\"] is False:\n                # Get the name of the collection associated with the Model.\n                collection_name = model_state[\"collection_name\"]\n                # Delete data for non-existent Model.\n                await super_collection.delete_one({\"collection_name\": collection_name})\n                # Delete collection associated with non-existent Model.\n                await database.drop_collection(collection_name)  # type: ignore[union-attr]\n\n    async def migrate(self) -&gt; None:\n        \"\"\"Run migration process.\n\n        1) Update the state of Models in the super collection.\n        2) Register new Models in the super collection.\n        3) Check changes in models and (if necessary) apply in appropriate collections.\n        \"\"\"\n        # Reset the condition of the models in a super collection.\n        # Switch the `is_model_exist` parameter in the condition `False`.\n        await self.reset()\n        # Get access to database.\n        database = constants.MONGO_DATABASE\n        # Get access to super collection.\n        super_collection: AsyncCollection = database[constants.SUPER_COLLECTION_NAME]\n        #\n        for cls_model in self.model_list:\n            # Get metadata of current Model.\n            metadata = cls_model.META\n            # Get the state of the current model from a super collection.\n            model_state = await self.model_state(metadata)\n            # Review change of fields in the current Model and (if necessary)\n            # update documents in the appropriate Collection.\n            if model_state[\"field_name_and_type\"] != metadata[\"field_name_and_type\"]:\n                # Get a list of new fields.\n                new_fields: list[str] = self.new_fields(metadata, model_state)\n                # Get collection for current Model.\n                model_collection: AsyncCollection = database[model_state[\"collection_name\"]]\n                # Add new fields with default value or\n                # update existing fields whose field type has changed.\n                async for mongo_doc in model_collection.find():\n                    for field_name in new_fields:\n                        field_type = metadata[\"field_name_and_type\"].get(field_name)\n                        if field_type is not None:\n                            if field_type == \"FileField\":\n                                file_info = {\n                                    \"path\": \"\",\n                                    \"is_delete\": True,\n                                    \"save_as_is\": False,\n                                }\n                                mongo_doc[field_name] = file_info\n                            elif field_type == \"ImageField\":\n                                img_info = {\n                                    \"path\": \"\",\n                                    \"is_delete\": True,\n                                    \"save_as_is\": False,\n                                }\n                                mongo_doc[field_name] = img_info\n                            else:\n                                mongo_doc[field_name] = None\n                    #\n                    inst_model = cls_model.from_mongo_doc(mongo_doc)\n                    result_check: dict[str, Any] = await inst_model.check(\n                        is_save=True,\n                        collection=model_collection,\n                        is_migration_process=True,\n                    )\n                    if not result_check[\"is_valid\"]:\n                        print(colored(\"\\n!!!&gt;&gt;MIGRATION&lt;&lt;!!!\", \"red\", attrs=[\"bold\"]))  # noqa: T201\n                        inst_model.print_err()\n                        msg: str = \"Migration failed.\"\n                        logger.critical(msg)\n                        raise PanicError(msg)\n                    # Get checked data.\n                    checked_data = result_check[\"data\"]\n                    # Add password from mongo_doc to checked_data.\n                    for field_name, field_type in metadata[\"field_name_and_type\"].items():\n                        if (\n                            field_type == \"PasswordField\"\n                            and model_state[\"field_name_and_type\"].get(field_name) == \"PasswordField\"\n                        ):\n                            checked_data[field_name] = mongo_doc[field_name]\n                    # Update date and time.\n                    checked_data[\"updated_at\"] = datetime.now(UTC_TIMEZONE)\n                    # Update the document in the database.\n                    await model_collection.replace_one(\n                        filter={\"_id\": checked_data[\"_id\"]},\n                        replacement=checked_data,\n                    )\n            #\n            # Refresh the dynamic fields data for the current model.\n            for field_name, field_data in metadata[\"data_dynamic_fields\"].items():\n                if model_state[\"data_dynamic_fields\"].get(field_name, False) == False:  # noqa: E712\n                    model_state[\"data_dynamic_fields\"][field_name] = field_data\n                else:\n                    metadata[\"data_dynamic_fields\"][field_name] = model_state[\"data_dynamic_fields\"][field_name]\n            # Refresh state of current Model.\n            model_state[\"data_dynamic_fields\"] = metadata[\"data_dynamic_fields\"]\n            model_state[\"field_name_and_type\"] = metadata[\"field_name_and_type\"]\n            await super_collection.replace_one(\n                filter={\"collection_name\": model_state[\"collection_name\"]},\n                replacement=model_state,\n            )\n        #\n        # Block the verification code.\n        constants.DEBUG = False\n        #\n        # Delete data for non-existent Models from a\n        # super collection and delete collections associated with those Models.\n        await self.napalm()\n        # Run indexing and apply fixture to current Model.\n        for cls_model in self.model_list:\n            # Run indexing.\n            await cls_model.indexing()\n            # Apply fixture to current Model.\n            fixture_name: str | None = cls_model.META[\"fixture_name\"]\n            if fixture_name is not None:\n                collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n                if await collection.estimated_document_count() == 0:\n                    await apply_fixture(\n                        fixture_name=fixture_name,\n                        cls_model=cls_model,\n                        collection=collection,\n                    )\n</code></pre>"},{"location":"pages/utils/migration/#ramifice.utils.migration.Migration.migrate","title":"<code>migrate()</code>  <code>async</code>","text":"<p>Run migration process.</p> <p>1) Update the state of Models in the super collection. 2) Register new Models in the super collection. 3) Check changes in models and (if necessary) apply in appropriate collections.</p> Source code in <code>src/ramifice/utils/migration.py</code> <pre><code>async def migrate(self) -&gt; None:\n    \"\"\"Run migration process.\n\n    1) Update the state of Models in the super collection.\n    2) Register new Models in the super collection.\n    3) Check changes in models and (if necessary) apply in appropriate collections.\n    \"\"\"\n    # Reset the condition of the models in a super collection.\n    # Switch the `is_model_exist` parameter in the condition `False`.\n    await self.reset()\n    # Get access to database.\n    database = constants.MONGO_DATABASE\n    # Get access to super collection.\n    super_collection: AsyncCollection = database[constants.SUPER_COLLECTION_NAME]\n    #\n    for cls_model in self.model_list:\n        # Get metadata of current Model.\n        metadata = cls_model.META\n        # Get the state of the current model from a super collection.\n        model_state = await self.model_state(metadata)\n        # Review change of fields in the current Model and (if necessary)\n        # update documents in the appropriate Collection.\n        if model_state[\"field_name_and_type\"] != metadata[\"field_name_and_type\"]:\n            # Get a list of new fields.\n            new_fields: list[str] = self.new_fields(metadata, model_state)\n            # Get collection for current Model.\n            model_collection: AsyncCollection = database[model_state[\"collection_name\"]]\n            # Add new fields with default value or\n            # update existing fields whose field type has changed.\n            async for mongo_doc in model_collection.find():\n                for field_name in new_fields:\n                    field_type = metadata[\"field_name_and_type\"].get(field_name)\n                    if field_type is not None:\n                        if field_type == \"FileField\":\n                            file_info = {\n                                \"path\": \"\",\n                                \"is_delete\": True,\n                                \"save_as_is\": False,\n                            }\n                            mongo_doc[field_name] = file_info\n                        elif field_type == \"ImageField\":\n                            img_info = {\n                                \"path\": \"\",\n                                \"is_delete\": True,\n                                \"save_as_is\": False,\n                            }\n                            mongo_doc[field_name] = img_info\n                        else:\n                            mongo_doc[field_name] = None\n                #\n                inst_model = cls_model.from_mongo_doc(mongo_doc)\n                result_check: dict[str, Any] = await inst_model.check(\n                    is_save=True,\n                    collection=model_collection,\n                    is_migration_process=True,\n                )\n                if not result_check[\"is_valid\"]:\n                    print(colored(\"\\n!!!&gt;&gt;MIGRATION&lt;&lt;!!!\", \"red\", attrs=[\"bold\"]))  # noqa: T201\n                    inst_model.print_err()\n                    msg: str = \"Migration failed.\"\n                    logger.critical(msg)\n                    raise PanicError(msg)\n                # Get checked data.\n                checked_data = result_check[\"data\"]\n                # Add password from mongo_doc to checked_data.\n                for field_name, field_type in metadata[\"field_name_and_type\"].items():\n                    if (\n                        field_type == \"PasswordField\"\n                        and model_state[\"field_name_and_type\"].get(field_name) == \"PasswordField\"\n                    ):\n                        checked_data[field_name] = mongo_doc[field_name]\n                # Update date and time.\n                checked_data[\"updated_at\"] = datetime.now(UTC_TIMEZONE)\n                # Update the document in the database.\n                await model_collection.replace_one(\n                    filter={\"_id\": checked_data[\"_id\"]},\n                    replacement=checked_data,\n                )\n        #\n        # Refresh the dynamic fields data for the current model.\n        for field_name, field_data in metadata[\"data_dynamic_fields\"].items():\n            if model_state[\"data_dynamic_fields\"].get(field_name, False) == False:  # noqa: E712\n                model_state[\"data_dynamic_fields\"][field_name] = field_data\n            else:\n                metadata[\"data_dynamic_fields\"][field_name] = model_state[\"data_dynamic_fields\"][field_name]\n        # Refresh state of current Model.\n        model_state[\"data_dynamic_fields\"] = metadata[\"data_dynamic_fields\"]\n        model_state[\"field_name_and_type\"] = metadata[\"field_name_and_type\"]\n        await super_collection.replace_one(\n            filter={\"collection_name\": model_state[\"collection_name\"]},\n            replacement=model_state,\n        )\n    #\n    # Block the verification code.\n    constants.DEBUG = False\n    #\n    # Delete data for non-existent Models from a\n    # super collection and delete collections associated with those Models.\n    await self.napalm()\n    # Run indexing and apply fixture to current Model.\n    for cls_model in self.model_list:\n        # Run indexing.\n        await cls_model.indexing()\n        # Apply fixture to current Model.\n        fixture_name: str | None = cls_model.META[\"fixture_name\"]\n        if fixture_name is not None:\n            collection: AsyncCollection = constants.MONGO_DATABASE[cls_model.META[\"collection_name\"]]\n            if await collection.estimated_document_count() == 0:\n                await apply_fixture(\n                    fixture_name=fixture_name,\n                    cls_model=cls_model,\n                    collection=collection,\n                )\n</code></pre>"},{"location":"pages/utils/migration/#ramifice.utils.migration.Migration.model_state","title":"<code>model_state(metadata)</code>  <code>async</code>","text":"<p>Get the state of the current model from a super collection.</p> Source code in <code>src/ramifice/utils/migration.py</code> <pre><code>async def model_state(self, metadata: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Get the state of the current model from a super collection.\"\"\"\n    # Get access to super collection.\n    # (Contains Model state and dynamic field data.)\n    super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n    # Get state of current Model.\n    model_state: dict[str, Any] | None = await super_collection.find_one(\n        {\"collection_name\": metadata[\"collection_name\"]},\n    )\n    if model_state is not None:\n        model_state[\"is_model_exist\"] = True\n    else:\n        # Create a state for new Model.\n        model_state = {\n            \"collection_name\": metadata[\"collection_name\"],\n            \"field_name_and_type\": metadata[\"field_name_and_type\"],\n            \"data_dynamic_fields\": metadata[\"data_dynamic_fields\"],\n            \"is_model_exist\": True,\n        }\n        await super_collection.insert_one(model_state)\n    return model_state\n</code></pre>"},{"location":"pages/utils/migration/#ramifice.utils.migration.Migration.napalm","title":"<code>napalm()</code>  <code>async</code>","text":"<p>Delete data for non-existent Models from a super collection, delete collections associated with those Models.</p> Source code in <code>src/ramifice/utils/migration.py</code> <pre><code>async def napalm(self) -&gt; None:\n    \"\"\"Delete data for non-existent Models from a super collection,\n    delete collections associated with those Models.\n    \"\"\"  # noqa: D205\n    # Get access to database.\n    database = constants.MONGO_DATABASE\n    # Get access to super collection.\n    # (Contains Model state and dynamic field data.)\n    super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n    # Delete data for non-existent Models.\n    async for model_state in super_collection.find():\n        if model_state[\"is_model_exist\"] is False:\n            # Get the name of the collection associated with the Model.\n            collection_name = model_state[\"collection_name\"]\n            # Delete data for non-existent Model.\n            await super_collection.delete_one({\"collection_name\": collection_name})\n            # Delete collection associated with non-existent Model.\n            await database.drop_collection(collection_name)  # type: ignore[union-attr]\n</code></pre>"},{"location":"pages/utils/migration/#ramifice.utils.migration.Migration.new_fields","title":"<code>new_fields(metadata, model_state)</code>","text":"<p>Get a list of new fields that were added to Model.</p> Source code in <code>src/ramifice/utils/migration.py</code> <pre><code>def new_fields(self, metadata: dict[str, Any], model_state: dict[str, Any]) -&gt; list[str]:\n    \"\"\"Get a list of new fields that were added to Model.\"\"\"\n    new_fields: list[str] = []\n    for field_name, field_type in metadata[\"field_name_and_type\"].items():\n        old_field_type: str | None = model_state[\"field_name_and_type\"].get(field_name)\n        if old_field_type is None or old_field_type != field_type:\n            new_fields.append(field_name)\n    return new_fields\n</code></pre>"},{"location":"pages/utils/migration/#ramifice.utils.migration.Migration.reset","title":"<code>reset()</code>  <code>async</code>","text":"<p>Reset the condition of the models in a super collection.</p> <p>Switch the <code>is_model_exist</code> parameter in the condition <code>False</code>.</p> Source code in <code>src/ramifice/utils/migration.py</code> <pre><code>async def reset(self) -&gt; None:\n    \"\"\"Reset the condition of the models in a super collection.\n\n    Switch the `is_model_exist` parameter in the condition `False`.\n    \"\"\"\n    # Get access to super collection.\n    # (Contains Model state and dynamic field data.)\n    super_collection: AsyncCollection = constants.MONGO_DATABASE[constants.SUPER_COLLECTION_NAME]\n    # Switch the `is_model_exist` parameter in `False`.\n    async for model_state in super_collection.find():\n        q_filter = {\"collection_name\": model_state[\"collection_name\"]}\n        update = {\"$set\": {\"is_model_exist\": False}}\n        await super_collection.update_one(q_filter, update)\n</code></pre>"},{"location":"pages/utils/mixins/","title":"Mixins","text":"<p>Set of mixins for Models and Fields.</p>"},{"location":"pages/utils/mixins/#ramifice.utils.mixins.JsonMixin","title":"<code>JsonMixin</code>","text":"<p>Contains the methods for converting Fields to JSON and back.</p> Source code in <code>src/ramifice/utils/mixins.py</code> <pre><code>class JsonMixin:\n    \"\"\"Contains the methods for converting Fields to JSON and back.\"\"\"\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert object instance to a dictionary.\"\"\"\n        json_dict: dict[str, Any] = {}\n        for name, data in self.__dict__.items():\n            if not callable(data):\n                json_dict[name] = data\n        return json_dict\n\n    def to_json(self) -&gt; str:\n        \"\"\"Convert object instance to a JSON string.\"\"\"\n        return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n\n    @classmethod\n    def from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        obj = cls()\n        for name, data in json_dict.items():\n            obj.__dict__[name] = data\n        return obj\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Any:\n        \"\"\"Convert JSON string to a object instance.\"\"\"\n        json_dict = orjson.loads(json_str)\n        return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/utils/mixins/#ramifice.utils.mixins.JsonMixin.from_dict","title":"<code>from_dict(json_dict)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/utils/mixins.py</code> <pre><code>@classmethod\ndef from_dict(cls, json_dict: dict[str, Any]) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    obj = cls()\n    for name, data in json_dict.items():\n        obj.__dict__[name] = data\n    return obj\n</code></pre>"},{"location":"pages/utils/mixins/#ramifice.utils.mixins.JsonMixin.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Convert JSON string to a object instance.</p> Source code in <code>src/ramifice/utils/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Any:\n    \"\"\"Convert JSON string to a object instance.\"\"\"\n    json_dict = orjson.loads(json_str)\n    return cls.from_dict(json_dict)\n</code></pre>"},{"location":"pages/utils/mixins/#ramifice.utils.mixins.JsonMixin.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert object instance to a dictionary.</p> Source code in <code>src/ramifice/utils/mixins.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert object instance to a dictionary.\"\"\"\n    json_dict: dict[str, Any] = {}\n    for name, data in self.__dict__.items():\n        if not callable(data):\n            json_dict[name] = data\n    return json_dict\n</code></pre>"},{"location":"pages/utils/mixins/#ramifice.utils.mixins.JsonMixin.to_json","title":"<code>to_json()</code>","text":"<p>Convert object instance to a JSON string.</p> Source code in <code>src/ramifice/utils/mixins.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Convert object instance to a JSON string.\"\"\"\n    return orjson.dumps(self.to_dict()).decode(\"utf-8\")\n</code></pre>"},{"location":"pages/utils/tools/","title":"Tools","text":"<p>Global collection of auxiliary methods.</p>"},{"location":"pages/utils/tools/#ramifice.utils.tools.get_file_size","title":"<code>get_file_size(path)</code>  <code>async</code>","text":"<p>Get file size in bytes.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>async def get_file_size(path: str) -&gt; int:\n    \"\"\"Get file size in bytes.\"\"\"\n    size: int = await to_thread(getsize, path)\n    return size\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.hash_to_obj_id","title":"<code>hash_to_obj_id(hash)</code>","text":"<p>Get ObjectId from hash string.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def hash_to_obj_id(hash: str | None) -&gt; ObjectId | None:\n    \"\"\"Get ObjectId from hash string.\"\"\"\n    return ObjectId(hash) if bool(hash) else None\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.is_color","title":"<code>is_color(color_code)</code>","text":"<p>Validate Color code.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def is_color(color_code: str | None) -&gt; bool:\n    \"\"\"Validate Color code.\"\"\"\n    return REGEX[\"color_code\"].match(str(color_code)) is not None\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.is_email","title":"<code>is_email(email)</code>  <code>async</code>","text":"<p>Validate Email address.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>async def is_email(email: str | None) -&gt; bool:\n    \"\"\"Validate Email address.\"\"\"\n    try:\n        await to_thread(\n            validate_email,\n            str(email),\n            check_deliverability=True,\n        )\n    except EmailNotValidError:\n        return False\n    return True\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.is_ip","title":"<code>is_ip(address)</code>","text":"<p>Validate IP address.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def is_ip(address: str | int | None) -&gt; bool:\n    \"\"\"Validate IP address.\"\"\"\n    try:\n        ipaddress.ip_address(str(address))\n    except ValueError:\n        return False\n    return True\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.is_mongo_id","title":"<code>is_mongo_id(oid)</code>","text":"<p>Validation of the Mongodb identifier.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def is_mongo_id(oid: Any) -&gt; bool:\n    \"\"\"Validation of the Mongodb identifier.\"\"\"\n    return ObjectId.is_valid(oid)\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.is_password","title":"<code>is_password(password)</code>","text":"<p>Validate Password.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def is_password(password: str | None) -&gt; bool:\n    \"\"\"Validate Password.\"\"\"\n    return REGEX[\"password\"].match(str(password)) is not None\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.is_phone","title":"<code>is_phone(number)</code>","text":"<p>Validate Phone number.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def is_phone(number: str | None) -&gt; bool:\n    \"\"\"Validate Phone number.\"\"\"\n    try:\n        phone = phonenumbers.parse(str(number))\n        if not phonenumbers.is_valid_number(phone):\n            return False\n    except phonenumbers.phonenumberutil.NumberParseException:\n        return False\n    return True\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.is_url","title":"<code>is_url(url)</code>","text":"<p>Validate URL address.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def is_url(url: str | None) -&gt; bool:\n    \"\"\"Validate URL address.\"\"\"\n    result = urlparse(str(url))\n    return not (not result.scheme or not result.netloc)\n</code></pre>"},{"location":"pages/utils/tools/#ramifice.utils.tools.normal_email","title":"<code>normal_email(email)</code>","text":"<p>Normalizing email address.</p> <p>Use this before requeste to a database. For example, on the login page.</p> Source code in <code>src/ramifice/utils/tools.py</code> <pre><code>def normal_email(email: str | None) -&gt; str | None:\n    \"\"\"Normalizing email address.\n\n    Use this before requeste to a database.\n    For example, on the login page.\n    \"\"\"\n    normal: str | None = None\n    try:\n        emailinfo = validate_email(\n            str(email),\n            check_deliverability=False,\n        )\n        normal = emailinfo.normalized\n    except EmailNotValidError:\n        pass\n    return normal\n</code></pre>"},{"location":"pages/utils/translations/","title":"Translations","text":"<p>Localization of translations.</p> <p>The module contains the following variables:</p> <ul> <li><code>CURRENT_LOCALE</code> - Code of current language.</li> <li><code>DEFAULT_LOCALE</code> - Language code by default.</li> <li><code>LANGUAGES</code> - List of codes supported by languages.</li> <li><code>gettext</code> - The object of the current translator.</li> <li><code>ngettext</code> - The object of the current translator.</li> </ul> <p>The module contains the following functions:</p> <ul> <li><code>change_locale</code> - To change the current language and translation object.</li> </ul> <p>CKEditor supported languages:</p> <p>af | ar | ast | az | bg | ca | cs | da | de | de_ch | el | en | en_au | en_gb | eo | es | et | eu | fa | fi | fr | gl | gu | he | hi | hr | hu | id | it | ja | km | kn | ko | ku | lt | lv | ms | nb | ne | nl | no | oc | pl | pt | pt_br | ro | ru | si | sk | sl | sq | sr | sr_latn | sv | th | tk | tr | tt | ug | uk | vi | zh | zh_cn</p>"},{"location":"pages/utils/translations/#ramifice.utils.translations.add_languages","title":"<code>add_languages(default_locale, languages)</code>","text":"<p>Add languages.</p> Source code in <code>src/ramifice/utils/translations.py</code> <pre><code>def add_languages(\n    default_locale: str,\n    languages: frozenset[str],\n) -&gt; None:\n    \"\"\"Add languages.\"\"\"\n    global DEFAULT_LOCALE, LANGUAGES  # noqa: PLW0603\n    if default_locale not in languages:\n        msg = \"DEFAULT_LOCALE is not included in the LANGUAGES!\"\n        logger.critical(msg)\n        raise PanicError(msg)\n    DEFAULT_LOCALE = default_locale\n    LANGUAGES = languages\n</code></pre>"},{"location":"pages/utils/translations/#ramifice.utils.translations.change_locale","title":"<code>change_locale(lang_code)</code>","text":"<p>Change current language.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ramifice import translations\n&gt;&gt;&gt; translations.change_locale(\"ru\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>lang_code</code> <code>str</code> <p>Language code.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Object <code>None</code>.</p> Source code in <code>src/ramifice/utils/translations.py</code> <pre><code>def change_locale(lang_code: str) -&gt; None:\n    \"\"\"Change current language.\n\n    Examples:\n        &gt;&gt;&gt; from ramifice import translations\n        &gt;&gt;&gt; translations.change_locale(\"ru\")\n\n    Args:\n        lang_code: Language code.\n\n    Returns:\n        Object `None`.\n    \"\"\"\n    global CURRENT_LOCALE, _, gettext, ngettext  # noqa: PLW0603\n    if lang_code != CURRENT_LOCALE:\n        CURRENT_LOCALE = lang_code if lang_code in LANGUAGES else DEFAULT_LOCALE\n        _ = get_ramifice_translator(CURRENT_LOCALE).gettext\n        translator: NullTranslations = get_custom_translator(CURRENT_LOCALE)\n        gettext = translator.gettext\n        ngettext = translator.ngettext\n</code></pre>"},{"location":"pages/utils/translations/#ramifice.utils.translations.get_custom_translator","title":"<code>get_custom_translator(lang_code)</code>","text":"<p>Get an object of translation for the desired language, for custom project.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ramifice import translations\n&gt;&gt;&gt; gettext = translations.get_custom_translator(\"en\").gettext\n&gt;&gt;&gt; msg = gettext(\"Hello World!\")\n&gt;&gt;&gt; print(msg)\nHello World!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>lang_code</code> <code>str</code> <p>Language code.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Object of translation for the desired language.</p> Source code in <code>src/ramifice/utils/translations.py</code> <pre><code>def get_custom_translator(lang_code: str) -&gt; Any:\n    \"\"\"Get an object of translation for the desired language, for custom project.\n\n    Examples:\n        &gt;&gt;&gt; from ramifice import translations\n        &gt;&gt;&gt; gettext = translations.get_custom_translator(\"en\").gettext\n        &gt;&gt;&gt; msg = gettext(\"Hello World!\")\n        &gt;&gt;&gt; print(msg)\n        Hello World!\n\n    Args:\n        lang_code: Language code.\n\n    Returns:\n        Object of translation for the desired language.\n    \"\"\"\n    return custom_translations.get(\n        lang_code,\n        custom_translations[DEFAULT_LOCALE],\n    )\n</code></pre>"},{"location":"pages/utils/translations/#ramifice.utils.translations.get_ramifice_translator","title":"<code>get_ramifice_translator(lang_code)</code>","text":"<p>Get an object of translation for the desired language, for Ramifice.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ramifice import translations\n&gt;&gt;&gt; _ = translations.get_ramifice_translator(\"en\").gettext\n&gt;&gt;&gt; msg = _(\"Hello World!\")\n&gt;&gt;&gt; print(msg)\nHello World!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>lang_code</code> <code>str</code> <p>Language code.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Object of translation for the desired language.</p> Source code in <code>src/ramifice/utils/translations.py</code> <pre><code>def get_ramifice_translator(lang_code: str) -&gt; Any:\n    \"\"\"Get an object of translation for the desired language, for Ramifice.\n\n    Examples:\n        &gt;&gt;&gt; from ramifice import translations\n        &gt;&gt;&gt; _ = translations.get_ramifice_translator(\"en\").gettext\n        &gt;&gt;&gt; msg = _(\"Hello World!\")\n        &gt;&gt;&gt; print(msg)\n        Hello World!\n\n    Args:\n        lang_code: Language code.\n\n    Returns:\n        Object of translation for the desired language.\n    \"\"\"\n    return ramifice_translations.get(\n        lang_code,\n        ramifice_translations[DEFAULT_LOCALE],\n    )\n</code></pre>"},{"location":"pages/utils/unit/","title":"Unit","text":"<p>Unit - Data management in dynamic fields.</p>"},{"location":"pages/utils/unit/#ramifice.utils.unit.Unit","title":"<code>Unit</code>","text":"<p>               Bases: <code>JsonMixin</code></p> <p>Unit of information for <code>choices</code> parameter in dynamic field types.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The name of the dynamic field.</p> required <code>title</code> <code>dict[str, str]</code> <p>The name of the choice item.</p> required <code>value</code> <code>float | int | str</code> <p>The value of the choice item.</p> required <code>is_delete</code> <code>bool</code> <p>True - if you need to remove the item of choice.</p> <code>False</code> Source code in <code>src/ramifice/utils/unit.py</code> <pre><code>class Unit(JsonMixin):\n    \"\"\"Unit of information for `choices` parameter in dynamic field types.\n\n    Args:\n        field: The name of the dynamic field.\n        title: The name of the choice item.\n        value: The value of the choice item.\n        is_delete: True - if you need to remove the item of choice.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        field: str,\n        title: dict[str, str],  # Example: {\"en\": \"Title\", \"ru\": \"\u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a\"}\n        value: float | int | str,\n        is_delete: bool = False,\n    ) -&gt; None:\n        # Check the match of types.\n        if not isinstance(field, str):\n            msg = \"Class: `Unit` &gt; Field: `field` =&gt; Not \u0430 `str` type!\"\n            raise PanicError(msg)\n        if not isinstance(title, dict):\n            msg = \"Class: `Unit` &gt; Field: `title` =&gt; Not \u0430 `str` type! \" + 'Example: {\"en\": \"Title\", \"ru\": \"\u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a\"}'\n            raise PanicError(msg)\n        if not isinstance(value, (float, int, str)):\n            msg = \"Class: `Unit` &gt; Field: `value` =&gt; Not a `float | int | str` type!\"\n            raise PanicError(msg)\n        if not isinstance(is_delete, bool):\n            msg = \"Class: `Unit` &gt; Field: `is_delete` =&gt; Not a `bool` type!\"\n            raise PanicError(msg)\n\n        JsonMixin.__init__(self)\n\n        self.field = field\n        self.title = title\n        self.value = value\n        self.is_delete = is_delete\n\n        self.check_empty_arguments()\n\n    def check_empty_arguments(self) -&gt; None:\n        \"\"\"Check the arguments for empty values.\n\n        Returns:\n            `None` or raised exception `PanicError`.\n        \"\"\"\n        field_name: str = \"\"\n\n        if len(self.field) == 0:\n            field_name = \"field\"\n        elif len(self.title) == 0:\n            field_name = \"title\"\n        elif isinstance(self.value, str) and len(self.value) == 0:\n            field_name = \"value\"\n\n        if len(field_name) &gt; 0:\n            msg = (\n                \"Method: `unit_manager` &gt; \"\n                + \"Argument: `unit` &gt; \"\n                + f\"Field: `{field_name}` =&gt; \"\n                + \"Must not be empty!\"\n            )\n            logger.critical(msg)\n            raise PanicError(msg)\n</code></pre>"},{"location":"pages/utils/unit/#ramifice.utils.unit.Unit.check_empty_arguments","title":"<code>check_empty_arguments()</code>","text":"<p>Check the arguments for empty values.</p> <p>Returns:</p> Type Description <code>None</code> <p><code>None</code> or raised exception <code>PanicError</code>.</p> Source code in <code>src/ramifice/utils/unit.py</code> <pre><code>def check_empty_arguments(self) -&gt; None:\n    \"\"\"Check the arguments for empty values.\n\n    Returns:\n        `None` or raised exception `PanicError`.\n    \"\"\"\n    field_name: str = \"\"\n\n    if len(self.field) == 0:\n        field_name = \"field\"\n    elif len(self.title) == 0:\n        field_name = \"title\"\n    elif isinstance(self.value, str) and len(self.value) == 0:\n        field_name = \"value\"\n\n    if len(field_name) &gt; 0:\n        msg = (\n            \"Method: `unit_manager` &gt; \"\n            + \"Argument: `unit` &gt; \"\n            + f\"Field: `{field_name}` =&gt; \"\n            + \"Must not be empty!\"\n        )\n        logger.critical(msg)\n        raise PanicError(msg)\n</code></pre>"}]}